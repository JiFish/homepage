{"mappings":"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","sources":["<anon>","src/js/main.js","src/js/config.js","src/js/state.js","src/js/grid.js","src/js/helpers.js","src/js/plants/registry.js","src/js/plants/Reed.js","src/js/plants/Plant.js","src/js/plants/Daisy.js","src/js/plants/Cactus.js","src/js/plants/Chromatic.js","src/js/plants/Wandering.js","src/js/plants/Blight.js","src/js/plants/Mushroom.js","src/js/plants/Lichen.js","src/js/plants/Lily.js","src/js/plants/Geranium.js","src/js/plants/Fence.js","src/js/save.js","src/js/ui.js","src/js/terrain.js","src/js/tick.js","src/js/render.js"],"sourcesContent":["const $ba30e20475feac5a$export$cf9ad17145f68381 = 20;\nconst $ba30e20475feac5a$export$5ea37ee797880001 = 40;\nconst $ba30e20475feac5a$export$5613db76819ec00b = 30;\nconst $ba30e20475feac5a$export$315a7bb69757d5a7 = \"tiny_garden_save_v1\";\nconst $ba30e20475feac5a$export$4b203929188df7d1 = 1000;\nconst $ba30e20475feac5a$export$34ddeca23ac38a20 = [\n    \"mud\",\n    \"grass\",\n    \"water\",\n    \"sand\",\n    \"stone\"\n];\nconst $ba30e20475feac5a$export$619b51fcfd7c4956 = {\n    mud: \"#604834\",\n    grass: \"#448c4a\",\n    water: \"#3860a4\",\n    sand: \"#c6b670\",\n    stone: \"#aaaaaa\"\n};\nconst $ba30e20475feac5a$export$4f193d7d85690f47 = {\n    gridLine: \"rgba(0,0,0,0.65)\"\n};\nconst $ba30e20475feac5a$export$555041af39b08b54 = 1000;\n\n\n\nfunction $29289ae2f853543e$export$b73337e033eb9f1f(fill) {\n    const g = [];\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++){\n        const row = [];\n        for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++)row.push(fill);\n        g.push(row);\n    }\n    return g;\n}\nfunction $29289ae2f853543e$export$39c1b8934bddc9a6() {\n    const g = [];\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++){\n        const row = [];\n        for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++)row.push(null);\n        g.push(row);\n    }\n    return g;\n}\n\n\n\nfunction $bd02c871d9c5ba8e$export$4e985c1b25c164db(x, y) {\n    return x >= 0 && x < (0, $ba30e20475feac5a$export$5ea37ee797880001) && y >= 0 && y < (0, $ba30e20475feac5a$export$5613db76819ec00b);\n}\nfunction $bd02c871d9c5ba8e$export$ae06a31eb29cbddb(x, y) {\n    return [\n        [\n            x + 1,\n            y\n        ],\n        [\n            x - 1,\n            y\n        ],\n        [\n            x,\n            y + 1\n        ],\n        [\n            x,\n            y - 1\n        ]\n    ];\n}\nfunction $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2(x, y) {\n    const out = [];\n    for(let dy = -1; dy <= 1; dy++)for(let dx = -1; dx <= 1; dx++){\n        if (dx === 0 && dy === 0) continue;\n        out.push([\n            x + dx,\n            y + dy\n        ]);\n    }\n    return out;\n}\nfunction $bd02c871d9c5ba8e$export$7a5825874deea16a(rng, arr) {\n    return arr[Math.floor(rng() * arr.length)];\n}\nfunction $bd02c871d9c5ba8e$export$7d15b64cf5a3a4c4(v, a, b) {\n    return Math.max(a, Math.min(b, v));\n}\nfunction $bd02c871d9c5ba8e$export$d22a027dada4117a(seed) {\n    let t = seed >>> 0;\n    return function() {\n        t += 0x6D2B79F5;\n        let x = t;\n        x = Math.imul(x ^ x >>> 15, x | 1);\n        x ^= x + Math.imul(x ^ x >>> 7, x | 61);\n        return ((x ^ x >>> 14) >>> 0) / 4294967296;\n    };\n}\nfunction $bd02c871d9c5ba8e$export$166e03518104bf21(ctx, x, y, w, h, r) {\n    const rr = $bd02c871d9c5ba8e$export$7d15b64cf5a3a4c4(r, 0, Math.min(w, h) / 2);\n    ctx.beginPath();\n    ctx.moveTo(x + rr, y);\n    ctx.arcTo(x + w, y, x + w, y + h, rr);\n    ctx.arcTo(x + w, y + h, x, y + h, rr);\n    ctx.arcTo(x, y + h, x, y, rr);\n    ctx.arcTo(x, y, x + w, y, rr);\n    ctx.closePath();\n}\n\n\n\n\n\nclass $2bd4c572d50c8c3c$export$72afe9c85ade6759 {\n    static typeName = \"plant\";\n    static displayName = \"Plant\";\n    static maxStage = 3;\n    static getDescription(_x, _y, _state) {\n        return this.displayName;\n    }\n    static canPlantOn(_x, _y, _state) {\n        return false;\n    }\n    static init(_x, _y, _state) {\n        return {};\n    }\n    static plant(x, y, state) {\n        state.plantGrid[y][x] = {\n            plantType: this.typeName,\n            stage: 0,\n            age: 0,\n            data: this.init(x, y, state)\n        };\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        if (st.stage < this.maxStage && st.age % 3 === 0) st.stage += 1;\n    }\n    static draw(_ctx, _px, _py, _state) {\n        ctx.strokeStyle = \"rgba(0,0,0,0.9)\";\n        ctx.lineWidth = 1;\n        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);\n    }\n    static _countPlantsInRadius(plantType, cx, cy, r, state) {\n        let n = 0;\n        for(let y = cy - r; y <= cy + r; y++)for(let x = cx - r; x <= cx + r; x++){\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(x, y)) continue;\n            const st = state.plantGrid[y][x];\n            if (st && st.plantType === plantType) n++;\n        }\n        return n;\n    }\n    static _countPlantsInMoore(plantType, cx, cy, state) {\n        let n = 0;\n        for(let dy = -1; dy <= 1; dy++)for(let dx = -1; dx <= 1; dx++){\n            if (dx === 0 && dy === 0) continue;\n            const x = cx + dx;\n            const y = cy + dy;\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(x, y)) continue;\n            const st = state.plantGrid[y][x];\n            if (st && st.plantType === plantType) n++;\n        }\n        return n;\n    }\n    static _isCrowdedForSpreading(x, y, state) {\n        // If 6+ of the 8 surrounding tiles contain any plant, treat as too crowded.\n        let occupied = 0;\n        for (const [nx, ny] of (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y)){\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n            if (state.plantGrid[ny][nx]) occupied++;\n        }\n        return occupied >= 5;\n    }\n    static _trySpreadTo(plantType, _fromX, _fromY, toX, toY, canPlantOnFn, state) {\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(toX, toY)) return false;\n        if (state.plantGrid[toY][toX]) return false;\n        if (!canPlantOnFn(toX, toY, state)) return false;\n        if (this._isCrowdedForSpreading(toX, toY, state)) return false;\n        this.plant(toX, toY, state);\n        return true;\n    }\n}\n\n\nclass $e6d73616bebf33a6$export$e6c4aaad6785574a extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"reed\";\n    static displayName = \"Reed\";\n    static maxStage = 4;\n    static canPlantOn(x, y, state) {\n        const baseTile = state.baseGrid[y][x];\n        if (baseTile === \"mud\") return true;\n        if (baseTile !== \"water\") return false;\n        return !$e6d73616bebf33a6$export$e6c4aaad6785574a._isDeepWaterPocket(x, y, state);\n    }\n    static _isDeepWaterPocket(x, y, state) {\n        // \"Deep water pocket\" means:\n        // tile is water AND all 8 neighbours are water.\n        if (state.baseGrid[y][x] !== \"water\") return false;\n        for (const [nx, ny] of (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y)){\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) return false;\n            if (state.baseGrid[ny][nx] !== \"water\") return false;\n        }\n        return true;\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        const fast = state.baseGrid[y][x] === \"water\" ? 2 : 3;\n        if (st.stage < this.maxStage && st.age % fast === 0) st.stage += 1;\n        if (st.stage < 3) return;\n        if (st.age % 5 !== 0) return;\n        const cap = state.baseGrid[y][x] === \"water\" ? 10 : 7;\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\n        if (local >= cap) return;\n        const orth = (0, $bd02c871d9c5ba8e$export$ae06a31eb29cbddb)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        for(let i = orth.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [orth[i], orth[j]] = [\n                orth[j],\n                orth[i]\n            ];\n        }\n        const fill = local / cap;\n        const chance = 0.45 * (1.0 - fill);\n        if (state.rng() > chance) return;\n        const waterFirst = orth.slice().sort((a, b)=>{\n            const ta = state.baseGrid[a[1]][a[0]] === \"water\" ? 0 : 1;\n            const tb = state.baseGrid[b[1]][b[0]] === \"water\" ? 0 : 1;\n            return ta - tb;\n        });\n        for (const [nx, ny] of waterFirst){\n            if (this._trySpreadTo(this.typeName, x, y, nx, ny, this.canPlantOn, state)) break;\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const bottom = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 4;\n        const maxH = (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 8;\n        const height = Math.floor((st.stage + 1) / (this.maxStage + 1) * maxH) + 6;\n        const top = bottom - height;\n        const midX = px + Math.floor((0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = \"rgb(60,170,90)\";\n        ctx.beginPath();\n        ctx.moveTo(midX, bottom);\n        ctx.lineTo(midX, top);\n        ctx.stroke();\n        ctx.strokeStyle = \"rgb(80,220,120)\";\n        ctx.beginPath();\n        ctx.moveTo(midX, top + 6);\n        ctx.lineTo(midX + 6, top + 2);\n        ctx.moveTo(midX, top + 10);\n        ctx.lineTo(midX - 6, top + 6);\n        ctx.stroke();\n    }\n}\n\n\n\n\n\nclass $596ac2c908efdf81$export$9a60c84efaf62b31 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"daisy\";\n    static displayName = \"Daisy\";\n    static maxStage = 3;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return this.displayName + \" (\" + st.data.color + \")\";\n    }\n    static init(_x, _y, _state) {\n        return {\n            color: \"white\"\n        };\n    }\n    static canPlantOn(x, y, state) {\n        const baseTile = state.baseGrid[y][x];\n        return baseTile === \"grass\" || baseTile === \"mud\";\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        if (st.stage < this.maxStage && st.age % 3 === 0) st.stage += 1;\n        if (st.stage < this.maxStage) return;\n        if (st.age % 6 !== 0) return;\n        const local = this._countPlantsInMoore(this.typeName, x, y, state);\n        if (local >= 3) return;\n        const candidates = (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        for(let i = candidates.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [candidates[i], candidates[j]] = [\n                candidates[j],\n                candidates[i]\n            ];\n        }\n        candidates.sort((a, b)=>{\n            const ca = this._countPlantsInMoore(this.typeName, a[0], a[1], state);\n            const cb = this._countPlantsInMoore(this.typeName, b[0], b[1], state);\n            return ca - cb;\n        });\n        if (state.rng() > 0.55) return;\n        // Small chance the new daisy mutates to a different colour.\n        const mutationChance = 0.08;\n        const colours = [\n            \"white\",\n            \"yellow\",\n            \"pink\",\n            \"lavender\"\n        ];\n        const parentColour = st.data?.color ?? \"white\";\n        let childColour = parentColour;\n        if (state.rng() < mutationChance) {\n            const options = colours.filter((c)=>c !== parentColour);\n            childColour = options[Math.floor(state.rng() * options.length)];\n        }\n        for (const [nx, ny] of candidates){\n            if (this._countPlantsInMoore(this.typeName, nx, ny, state) >= 2) continue;\n            if (this._trySpreadTo(this.typeName, x, y, nx, ny, this.canPlantOn, state)) {\n                // Apply inherited/mutated colour to the newly planted daisy.\n                const child = state.plantGrid[ny][nx];\n                if (child) child.data = {\n                    ...child.data || {},\n                    color: childColour\n                };\n                break;\n            }\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = \"rgb(70,180,90)\";\n        ctx.beginPath();\n        ctx.moveTo(cx, py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 4);\n        ctx.lineTo(cx, cy);\n        ctx.stroke();\n        const petalR = 2 + st.stage;\n        const centreR = 2 + Math.max(0, st.stage - 1);\n        const colourByName = {\n            white: \"rgb(240,240,240)\",\n            yellow: \"rgb(246, 255, 163)\",\n            pink: \"rgb(80, 160, 230)\",\n            lavender: \"rgb(220, 208, 255)\"\n        };\n        const petalColour = colourByName[st.data?.color] ?? colourByName.white;\n        if (st.stage >= 1) {\n            ctx.fillStyle = petalColour;\n            const pts = [\n                [\n                    0,\n                    -5\n                ],\n                [\n                    5,\n                    0\n                ],\n                [\n                    0,\n                    5\n                ],\n                [\n                    -5,\n                    0\n                ],\n                [\n                    4,\n                    -4\n                ],\n                [\n                    -4,\n                    -4\n                ],\n                [\n                    4,\n                    4\n                ],\n                [\n                    -4,\n                    4\n                ]\n            ];\n            for (const [dx, dy] of pts){\n                ctx.beginPath();\n                ctx.arc(cx + dx, cy + dy, petalR, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n        ctx.fillStyle = \"rgb(240,210,60)\";\n        ctx.beginPath();\n        ctx.arc(cx, cy, Math.max(2, centreR), 0, Math.PI * 2);\n        ctx.fill();\n    }\n}\n\n\n\n\n\nclass $aee5caf8454147df$export$78990388006fc58f extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"cactus\";\n    static displayName = \"Cactus\";\n    static maxStage = 4;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return this.displayName + \" (\" + st.data.colour + \" flower)\";\n    }\n    static canPlantOn(x, y, state) {\n        const baseTile = state.baseGrid[y][x];\n        return baseTile === \"sand\";\n    }\n    static init(_x, _y, state) {\n        const colours = [\n            \"red\",\n            \"yellow\",\n            \"blue\",\n            \"green\",\n            \"cyan\",\n            \"magenta\"\n        ];\n        return {\n            colour: colours[Math.floor(state.rng() * colours.length)],\n            flowering: false,\n            bloomAge: 0\n        };\n    }\n    static _colourToRGB(name) {\n        const map = {\n            red: \"rgb(255, 70, 70)\",\n            yellow: \"rgb(255, 235, 90)\",\n            blue: \"rgb(80, 140, 255)\",\n            green: \"rgb(90, 255, 130)\",\n            cyan: \"rgb(90, 245, 255)\",\n            magenta: \"rgb(255, 90, 235)\"\n        };\n        return map[name] || \"rgb(255, 255, 255)\";\n    }\n    static _pickSpreadTarget(x, y, state) {\n        const candidates = [];\n        for(let dy = -2; dy <= 2; dy++)for(let dx = -2; dx <= 2; dx++){\n            if (dx === 0 && dy === 0) continue;\n            const nx = x + dx;\n            const ny = y + dy;\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n            if (state.plantGrid[ny][nx]) continue;\n            if (!this.canPlantOn(nx, ny, state)) continue;\n            const nearCactus = this._countPlantsInRadius(this.typeName, nx, ny, 1, state);\n            if (nearCactus >= 3) continue;\n            const weight = nearCactus === 0 ? 6 : nearCactus === 1 ? 3 : 1;\n            candidates.push({\n                nx: nx,\n                ny: ny,\n                weight: weight\n            });\n        }\n        if (candidates.length === 0) return null;\n        let total = 0;\n        for (const c of candidates)total += c.weight;\n        let roll = state.rng() * total;\n        for (const c of candidates){\n            roll -= c.weight;\n            if (roll <= 0) return [\n                c.nx,\n                c.ny\n            ];\n        }\n        return [\n            candidates[0].nx,\n            candidates[0].ny\n        ];\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        // Slow-ish growth, but not too slow.\n        if (st.stage < this.maxStage && st.age % 4 === 0) st.stage += 1;\n        // Only mature cacti can flower/spread.\n        if (st.stage < 2) return;\n        // Flowering is rare, and slightly less likely in dense patches.\n        const local2 = this._countPlantsInRadius(this.typeName, x, y, 2, state);\n        if (!st.data.flowering) {\n            const crowdPenalty = Math.min(0.12, local2 * 0.02);\n            const startChance = 0.06 - crowdPenalty;\n            if (startChance > 0 && state.rng() < startChance) {\n                st.data.flowering = true;\n                st.data.bloomAge = 0;\n            }\n        } else {\n            st.data.bloomAge += 1;\n            // Flowering doesn't last long.\n            const baseStop = 0.12;\n            const timeStop = Math.min(0.45, st.data.bloomAge * 0.06);\n            if (state.rng() < baseStop + timeStop) {\n                st.data.flowering = false;\n                st.data.bloomAge = 0;\n                return;\n            }\n        }\n        // Spread only while flowering.\n        if (!st.data.flowering) return;\n        // Hard cap so deserts don't become solid cactus.\n        const local3 = this._countPlantsInRadius(this.typeName, x, y, 3, state);\n        if (local3 >= 10) return;\n        // Fast spread attempts while flowering.\n        if (state.rng() > 0.75) return;\n        const target = this._pickSpreadTarget(x, y, state);\n        if (!target) return;\n        const [nx, ny] = target;\n        this.plant(nx, ny, state);\n        // Inherit hidden colour, with occasional mutation.\n        const mutationChance = 0.08;\n        const colours = [\n            \"red\",\n            \"yellow\",\n            \"blue\",\n            \"green\",\n            \"cyan\",\n            \"magenta\"\n        ];\n        let childColour = st.data.colour;\n        if (state.rng() < mutationChance) {\n            const options = colours.filter((c)=>c !== st.data.colour);\n            childColour = options[Math.floor(state.rng() * options.length)];\n        }\n        const child = state.plantGrid[ny][nx];\n        child.data.colour = childColour;\n        child.data.flowering = false;\n        child.data.bloomAge = 0;\n    }\n    static draw(ctx, px, py, st) {\n        const pad = 5;\n        const bodyW = (0, $ba30e20475feac5a$export$cf9ad17145f68381) - pad * 2;\n        const maxH = (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 10;\n        const bodyH = Math.floor((st.stage + 1) / (this.maxStage + 1) * maxH) + 10;\n        const bx = px + pad;\n        const by = py + ((0, $ba30e20475feac5a$export$cf9ad17145f68381) - bodyH - 4);\n        ctx.fillStyle = \"rgb(60,160,110)\";\n        (0, $bd02c871d9c5ba8e$export$166e03518104bf21)(ctx, bx, by, bodyW, bodyH, 6);\n        ctx.fill();\n        // Spines (small ticks along the body, scaled with height)\n        ctx.strokeStyle = \"rgba(255,255,255,0.85)\";\n        ctx.lineWidth = 1;\n        const cols = 3;\n        for(let c = 0; c < cols; c++){\n            const sx = bx + Math.floor((c + 1) * bodyW / (cols + 1));\n            // Start a little below the top curve, end above the bottom\n            const top = by + 6;\n            const bottom = by + bodyH - 6;\n            // Space spines based on height\n            const step = 6;\n            for(let yy = top; yy <= bottom; yy += step){\n                const dir = (c + Math.floor(yy / step)) % 2 === 0 ? -1 : 1;\n                ctx.beginPath();\n                ctx.moveTo(sx, yy);\n                ctx.lineTo(sx + dir * 2, yy + 2);\n                ctx.stroke();\n            }\n        }\n        // Flower only while flowering.\n        if (st.data.flowering) {\n            const cap = this._colourToRGB(st.data.colour);\n            const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n            const topY = by + 4;\n            ctx.fillStyle = cap;\n            const petalR = 2;\n            const petals = [\n                [\n                    0,\n                    -3\n                ],\n                [\n                    3,\n                    0\n                ],\n                [\n                    0,\n                    3\n                ],\n                [\n                    -3,\n                    0\n                ],\n                [\n                    2,\n                    -2\n                ],\n                [\n                    -2,\n                    -2\n                ],\n                [\n                    2,\n                    2\n                ],\n                [\n                    -2,\n                    2\n                ]\n            ];\n            for (const [dx, dy] of petals){\n                ctx.beginPath();\n                ctx.arc(cx + dx, topY + dy, petalR, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            ctx.fillStyle = \"rgb(255, 235, 90)\";\n            ctx.beginPath();\n            ctx.arc(cx, topY, 2, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n}\n\n\n\n\n\nclass $c6a75af8f4fb0994$export$8ac37319d3c8ed52 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"chromatic\";\n    static displayName = \"Chromatic\";\n    static maxStage = 3;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return this.displayName + \" (\" + st.data.base + \")\";\n    }\n    static init(_x, _y, state) {\n        return {\n            base: state.baseGrid[_y][_x]\n        };\n    }\n    static canPlantOn(_x, _y, _state) {\n        return true;\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        if (st.stage < this.maxStage && st.age % 3 === 0) st.stage += 1;\n        if (st.stage < this.maxStage) return;\n        if (st.age % 7 !== 0) return;\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\n        if (local >= 6) return;\n        if (state.rng() > 0.25) return;\n        const candidates = (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        for(let i = candidates.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [candidates[i], candidates[j]] = [\n                candidates[j],\n                candidates[i]\n            ];\n        }\n        for (const [nx, ny] of candidates){\n            if (state.plantGrid[ny][nx]) continue;\n            if (this._isCrowdedForSpreading(nx, ny, state)) continue;\n            this.plant(nx, ny, state);\n            break;\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const colourByTile = {\n            mud: \"rgb(160, 110, 80)\",\n            grass: \"rgb(80, 200, 110)\",\n            water: \"rgb(80, 160, 230)\",\n            sand: \"rgb(240, 210, 120)\",\n            stone: \"rgb(109, 109, 109)\"\n        };\n        const fill = colourByTile[st.data.base] || \"rgb(180, 180, 180)\";\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const r = Math.max(3, Math.floor((0, $ba30e20475feac5a$export$cf9ad17145f68381) / 7) + st.stage * 2);\n        ctx.fillStyle = fill;\n        ctx.beginPath();\n        ctx.arc(cx, cy, r, 0, Math.PI * 2);\n        ctx.fill();\n        if (st.stage >= 2) {\n            ctx.strokeStyle = \"rgba(0,0,0,0.25)\";\n            ctx.lineWidth = 2;\n            ctx.beginPath();\n            ctx.arc(cx, cy, r - 2, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n    }\n}\n\n\n\n\n\nclass $709369b466786239$export$f19b6aa86008a814 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"wanderer\";\n    static displayName = \"Wanderer\";\n    static maxStage = 2;\n    static init(_x, _y, _state) {\n        return {\n            moved: false\n        };\n    }\n    static canPlantOn(x, y, state) {\n        const baseTile = state.baseGrid[y][x];\n        return baseTile !== \"water\" && baseTile !== \"mud\";\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        if (st.stage < this.maxStage && st.age % 3 === 0) st.stage += 1;\n        if (st.stage < this.maxStage) return;\n        if (st.age % 4 !== 0) return;\n        if (st.moved) return;\n        if (state.rng() > 0.75) return;\n        const adj = (0, $bd02c871d9c5ba8e$export$ae06a31eb29cbddb)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        const adjWanderers = [];\n        for (const [nx, ny] of adj){\n            const other = state.plantGrid[ny][nx];\n            if (other && other.plantType === this.typeName && other.stage === this.maxStage) adjWanderers.push([\n                nx,\n                ny\n            ]);\n        }\n        if (adjWanderers.length === 0) return;\n        const targets = [];\n        for (const [nx, ny] of adj){\n            if (state.plantGrid[ny][nx]) continue;\n            if (!this.canPlantOn(nx, ny, state)) continue;\n            targets.push([\n                nx,\n                ny\n            ]);\n        }\n        if (targets.length === 0) return;\n        const [tx, ty] = targets[Math.floor(state.rng() * targets.length)];\n        state.plantGrid[ty][tx] = {\n            plantType: this.typeName,\n            stage: 0,\n            age: 0\n        };\n        const [dx, dy] = adjWanderers[Math.floor(state.rng() * adjWanderers.length)];\n        state.plantGrid[dy][dx] = null;\n        st.moved = true;\n        state.magic += 1;\n    }\n    static draw(ctx, px, py, st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const r = 4 + st.stage * 2;\n        ctx.fillStyle = \"rgb(170, 110, 210)\";\n        ctx.beginPath();\n        ctx.arc(cx, cy, r, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.fillStyle = \"rgba(0,0,0,0.65)\";\n        ctx.beginPath();\n        ctx.arc(cx + 2, cy - 1, Math.max(1, r - 4), 0, Math.PI * 2);\n        ctx.fill();\n    }\n}\n\n\n\n\n\n\nclass $b0bb96384d34d4b5$export$58ada19cd5f35ee9 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"blight\";\n    static displayName = \"Blight\";\n    static maxStage = 1;\n    static canPlantOn(_x, _y, _state) {\n        return true;\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        st.stage = 1;\n        if (st.age % 2 !== 0) return;\n        const candidates = (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        if (candidates.length === 0) return;\n        for(let i = candidates.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [candidates[i], candidates[j]] = [\n                candidates[j],\n                candidates[i]\n            ];\n        }\n        for (const [nx, ny] of candidates){\n            const other = state.plantGrid[ny][nx];\n            if (!other) continue;\n            if (other.plantType === this.typeName) continue;\n            if (other.plantType === \"fence\") continue;\n            const otherCls = (0, $ae605652761ddad2$export$853aac19120fead9)[other.plantType];\n            if (!otherCls) continue;\n            if (other.stage !== otherCls.maxStage) continue;\n            state.plantGrid[ny][nx] = {\n                plantType: this.typeName,\n                stage: 1,\n                age: 0\n            };\n            break;\n        }\n        if (state.rng() > 0.9) state.plantGrid[y][x] = null;\n    }\n    static draw(ctx, px, py, _st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        ctx.fillStyle = \"rgb(10, 40, 90)\";\n        ctx.beginPath();\n        ctx.arc(cx, cy, Math.floor((0, $ba30e20475feac5a$export$cf9ad17145f68381) / 3), 0, Math.PI * 2);\n        ctx.fill();\n        ctx.strokeStyle = \"rgb(150, 80, 80)\";\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.arc(cx, cy, Math.floor((0, $ba30e20475feac5a$export$cf9ad17145f68381) / 3) - 2, 0, Math.PI * 2);\n        ctx.stroke();\n    }\n}\n\n\n\n\n\nclass $b8a2607e32fe05cd$export$b4a25d14236c1d1b extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"mushroom\";\n    static displayName = \"Mushroom\";\n    static maxStage = 3;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return `${this.displayName} (${st.data.cap} cap)`;\n    }\n    static canPlantOn(x, y, state) {\n        const baseTile = state.baseGrid[y][x];\n        return baseTile === \"grass\" || baseTile === \"mud\";\n    }\n    static init(_x, _y, _state) {\n        // Always plants brown.\n        return {\n            cap: \"brown\"\n        };\n    }\n    static _pickCapWeighted(state) {\n        const weighted = [\n            [\n                \"brown\",\n                40\n            ],\n            [\n                \"tan\",\n                18\n            ],\n            [\n                \"cream\",\n                14\n            ],\n            [\n                \"red\",\n                10\n            ],\n            [\n                \"orange\",\n                8\n            ],\n            [\n                \"yellow\",\n                7\n            ],\n            [\n                \"purple\",\n                5\n            ],\n            [\n                \"blue\",\n                3\n            ],\n            [\n                \"black\",\n                2\n            ],\n            [\n                \"white\",\n                2\n            ],\n            [\n                \"glow\",\n                1\n            ]\n        ];\n        let total = 0;\n        for (const [, w] of weighted)total += w;\n        let r = state.rng() * total;\n        for (const [name, w] of weighted){\n            r -= w;\n            if (r <= 0) return name;\n        }\n        return \"brown\";\n    }\n    static _countHostileAdjacency(tx, ty, state) {\n        // Count adjacent plants that are NOT mushroom and NOT fence.\n        let n = 0;\n        for (const [ax, ay] of (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(tx, ty)){\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(ax, ay)) continue;\n            const other = state.plantGrid[ay][ax];\n            if (!other) continue;\n            if (other.plantType === this.typeName) continue;\n            if (other.plantType === \"fence\") continue;\n            n++;\n        }\n        return n;\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        // Grow a bit slowly.\n        if (st.stage < this.maxStage && st.age % 4 === 0) st.stage += 1;\n        // Only burst-spread once mature and \"old enough\"\n        if (st.stage < this.maxStage) return;\n        if (st.age < 24) return;\n        if (st.age % 4 !== 0) return;\n        // Find valid adjacent squares\n        const valid = [];\n        for (const [nx, ny] of (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y)){\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n            // Can't plant there at all\n            if (!this.canPlantOn(nx, ny, state)) continue;\n            // Already occupied by any plant\n            if (state.plantGrid[ny][nx]) continue;\n            // Too many hostile neighbours (3+ non-mushroom, non-fence plants)\n            const hostile = this._countHostileAdjacency(nx, ny, state);\n            if (hostile >= 3) continue;\n            valid.push([\n                nx,\n                ny\n            ]);\n        }\n        // Only burst if there are enough good places to seed\n        if (valid.length < 4) return;\n        // Burst: the mushroom dies...\n        state.plantGrid[y][x] = null;\n        // ...and seeds each valid square with a 75% chance\n        for (const [sx, sy] of valid){\n            if (state.rng() > 0.45) continue;\n            this.plant(sx, sy, state);\n            const child = state.plantGrid[sy][sx];\n            if (child) {\n                if (state.rng() > 0.9) child.data.cap = this._pickCapWeighted(state);\n                else child.data.cap = st.data.cap;\n            }\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const bottom = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381);\n        const stemH = st.stage * 3;\n        const stemW = 3;\n        const capR = 3 + st.stage * 2;\n        const capByName = {\n            brown: \"rgb(140, 90, 60)\",\n            tan: \"rgb(190, 150, 105)\",\n            cream: \"rgb(220, 210, 190)\",\n            red: \"rgb(190, 60, 60)\",\n            orange: \"rgb(235, 140, 70)\",\n            yellow: \"rgb(245, 225, 90)\",\n            purple: \"rgb(150, 110, 190)\",\n            blue: \"rgb(90, 140, 255)\",\n            black: \"rgb(35, 35, 35)\",\n            white: \"rgb(245, 245, 245)\",\n            glow: \"rgb(120, 255, 210)\"\n        };\n        const capFill = capByName[st.data.cap] ?? capByName.brown;\n        // Stem\n        ctx.fillStyle = \"rgb(220, 210, 190)\";\n        ctx.fillRect(cx - Math.floor(stemW / 2), bottom - stemH, stemW, stemH);\n        // Cap\n        ctx.fillStyle = capFill;\n        ctx.beginPath();\n        ctx.arc(cx, bottom - stemH, capR, Math.PI, 0);\n        ctx.closePath();\n        ctx.fill();\n        // Spots when mature\n        if (st.stage >= 2) {\n            ctx.fillStyle = \"rgba(255,255,255,0.75)\";\n            const spots = [\n                [\n                    -2,\n                    -1\n                ],\n                [\n                    2,\n                    -2\n                ],\n                [\n                    0,\n                    -3\n                ]\n            ];\n            for (const [dx, dy] of spots){\n                ctx.beginPath();\n                ctx.arc(cx + dx, bottom - stemH + dy, 1, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n    }\n}\n\n\n\n\n\nclass $bd8aba2dd7d109a5$export$6c157b3ee5a67478 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"lichen\";\n    static displayName = \"Lichen\";\n    static maxStage = 3;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return this.displayName + \" (\" + st.data.hue + \")\";\n    }\n    static canPlantOn(x, y, state) {\n        return state.baseGrid[y][x] === \"stone\";\n    }\n    static init(_x, _y, state) {\n        const hues = [\n            \"mint\",\n            \"teal\",\n            \"gold\",\n            \"rust\"\n        ];\n        return {\n            hue: hues[Math.floor(state.rng() * hues.length)]\n        };\n    }\n    static _hueToColour(hue) {\n        const map = {\n            mint: \"rgb(150, 230, 170)\",\n            teal: \"rgb(90, 210, 200)\",\n            gold: \"rgb(235, 210, 120)\",\n            rust: \"rgb(210, 140, 90)\"\n        };\n        return map[hue] || \"rgb(200, 200, 200)\";\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        // Very slow growth\n        if (st.stage < this.maxStage && st.age % 6 === 0) st.stage += 1;\n        // Only mature lichen spreads\n        if (st.stage < this.maxStage) return;\n        // Spread is infrequent\n        if (st.age % 7 !== 0) return;\n        // Self-limit: don't spread if already dense nearby\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\n        if (local >= 7) return;\n        // Chance to spread (small)\n        if (state.rng() > 0.28) return;\n        // Prefer targets with 1-2 nearby lichen (patch edge), avoid packed centres\n        const candidates = (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        // Shuffle\n        for(let i = candidates.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [candidates[i], candidates[j]] = [\n                candidates[j],\n                candidates[i]\n            ];\n        }\n        candidates.sort((a, b)=>{\n            const ca = this._countPlantsInMoore(this.typeName, a[0], a[1], state);\n            const cb = this._countPlantsInMoore(this.typeName, b[0], b[1], state);\n            return ca - cb;\n        });\n        for (const [nx, ny] of candidates){\n            if (state.plantGrid[ny][nx]) continue;\n            if (!this.canPlantOn(nx, ny, state)) continue;\n            // Avoid landing in very crowded spots\n            const near = this._countPlantsInMoore(this.typeName, nx, ny, state);\n            if (near >= 4) continue;\n            this.plant(nx, ny, state);\n            // Inherit hue most of the time, with rare mutation\n            const mutationChance = 0.08;\n            const hues = [\n                \"mint\",\n                \"teal\",\n                \"gold\",\n                \"rust\"\n            ];\n            const parentHue = st.data.hue;\n            let childHue = parentHue;\n            if (state.rng() < mutationChance) {\n                const options = hues.filter((h)=>h !== parentHue);\n                childHue = options[Math.floor(state.rng() * options.length)];\n            }\n            const child = state.plantGrid[ny][nx];\n            child.data.hue = childHue;\n            break;\n        }\n        // Optional: very rare \"weathering\" effect\n        // Lichen slowly breaks stone into sand, but only when fully mature.\n        // Comment this out if you don't want plants to affect terrain.\n        if (state.rng() < 0.01) {\n            state.baseGrid[y][x] = \"sand\";\n            state.plantGrid[y][x] = null;\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        // Patch size grows with stage\n        const r = 3 + st.stage * 2;\n        ctx.fillStyle = this._hueToColour(st.data.hue);\n        // Blobby lichen patch (several circles)\n        const blobs = [\n            [\n                0,\n                0\n            ],\n            [\n                -3,\n                1\n            ],\n            [\n                3,\n                -1\n            ],\n            [\n                1,\n                3\n            ],\n            [\n                -1,\n                -3\n            ]\n        ];\n        for (const [dx, dy] of blobs){\n            ctx.beginPath();\n            ctx.arc(cx + dx, cy + dy, r / 2, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        // Outline hint so it reads on stone\n        ctx.strokeStyle = \"rgba(0,0,0,0.25)\";\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(cx, cy, r / 2, 0, Math.PI * 2);\n        ctx.stroke();\n    }\n}\n\n\n\n\n\nclass $a91a379d18c4a638$export$b75a6b61dc760dd5 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"lily\";\n    static displayName = \"Lily\";\n    static maxStage = 3;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return this.displayName + \" (\" + st.data.colour + \" flower)\";\n    }\n    static canPlantOn(x, y, state) {\n        if (state.baseGrid[y][x] !== \"water\") return false;\n        let waterCount = 0;\n        for (const [nx, ny] of (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y)){\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n            if (state.baseGrid[ny][nx] === \"water\") waterCount++;\n        }\n        return waterCount >= 6;\n    }\n    static init(_x, _y, state) {\n        const colours = [\n            \"red\",\n            \"yellow\",\n            \"blue\",\n            \"green\",\n            \"cyan\",\n            \"magenta\"\n        ];\n        return {\n            colour: colours[Math.floor(state.rng() * colours.length)],\n            flowering: false,\n            bloomAge: 0,\n            notchAngle: state.rng() * Math.PI * 2\n        };\n    }\n    static _colourToRGB(name) {\n        const map = {\n            red: \"rgb(255, 70, 70)\",\n            yellow: \"rgb(255, 235, 90)\",\n            blue: \"rgb(80, 140, 255)\",\n            green: \"rgb(90, 255, 130)\",\n            cyan: \"rgb(90, 245, 255)\",\n            magenta: \"rgb(255, 90, 235)\"\n        };\n        return map[name] || \"rgb(255, 255, 255)\";\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        // Grow slowly\n        if (st.stage < this.maxStage && st.age % 5 === 0) st.stage += 1;\n        // Only mature lilies can flower/spread\n        if (st.stage < 2) return;\n        // --- Flowering state machine (cactus-like) ---\n        if (!st.data.flowering) // Rare start\n        {\n            if (state.rng() < 0.05) {\n                st.data.flowering = true;\n                st.data.bloomAge = 0;\n            }\n        } else {\n            st.data.bloomAge += 1;\n            // Flowering doesn't last long\n            const baseStop = 0.10;\n            const timeStop = Math.min(0.50, st.data.bloomAge * 0.06);\n            if (state.rng() < baseStop + timeStop) {\n                st.data.flowering = false;\n                st.data.bloomAge = 0;\n                return;\n            }\n        }\n        // Optional: spread only while flowering, but very gently\n        if (!st.data.flowering) return;\n        if (st.age % 3 !== 0) return;\n        // Self-limit: don't overcrowd deep water\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\n        if (local >= 8) return;\n        if (state.rng() > 0.35) return;\n        const candidates = (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        // Shuffle\n        for(let i = candidates.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [candidates[i], candidates[j]] = [\n                candidates[j],\n                candidates[i]\n            ];\n        }\n        for (const [nx, ny] of candidates){\n            if (state.plantGrid[ny][nx]) continue;\n            if (!this.canPlantOn(nx, ny, state)) continue;\n            this.plant(nx, ny, state);\n            // Inherit flower colour, rare mutation\n            const mutationChance = 0.06;\n            const colours = [\n                \"red\",\n                \"yellow\",\n                \"blue\",\n                \"green\",\n                \"cyan\",\n                \"magenta\"\n            ];\n            let childColour = st.data.colour;\n            if (state.rng() < mutationChance) {\n                const options = colours.filter((c)=>c !== st.data.colour);\n                childColour = options[Math.floor(state.rng() * options.length)];\n            }\n            const child = state.plantGrid[ny][nx];\n            child.data.colour = childColour;\n            child.data.flowering = false;\n            child.data.bloomAge = 0;\n            break;\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        // Pad (leaf)\n        ctx.fillStyle = \"rgb(70, 170, 120)\";\n        ctx.beginPath();\n        ctx.ellipse(cx, cy + 2, 7, 5, 0, 0, Math.PI * 2);\n        ctx.fill();\n        // Notch cut (random direction)\n        const a = st.data.notchAngle;\n        ctx.fillStyle = \"rgba(0,0,0,0.25)\";\n        ctx.beginPath();\n        ctx.moveTo(cx, cy + 2);\n        ctx.arc(cx, cy + 2, 7, a - 0.35, a + 0.35);\n        ctx.closePath();\n        ctx.fill();\n        // Flower only while flowering\n        if (st.data.flowering) {\n            const col = this._colourToRGB(st.data.colour);\n            ctx.fillStyle = col;\n            const petalR = 2;\n            const petals = [\n                [\n                    0,\n                    -5\n                ],\n                [\n                    5,\n                    0\n                ],\n                [\n                    0,\n                    5\n                ],\n                [\n                    -5,\n                    0\n                ],\n                [\n                    3,\n                    -3\n                ],\n                [\n                    -3,\n                    -3\n                ],\n                [\n                    3,\n                    3\n                ],\n                [\n                    -3,\n                    3\n                ]\n            ];\n            for (const [dx, dy] of petals){\n                ctx.beginPath();\n                ctx.arc(cx + dx, cy - 3 + dy, petalR, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            ctx.fillStyle = \"rgb(255, 235, 90)\";\n            ctx.beginPath();\n            ctx.arc(cx, cy - 3, 2, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n}\n\n\n\n\n\nclass $910dbe2a5f197a40$export$aad56179aff78418 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"geranium\";\n    static displayName = \"Geranium\";\n    static maxStage = 3;\n    static getDescription(x, y, state) {\n        const st = state.plantGrid[y][x];\n        return this.displayName + \" (\" + st.data.colour + \")\";\n    }\n    static canPlantOn(x, y, state) {\n        const base = state.baseGrid[y][x];\n        return base === \"grass\" || base === \"mud\";\n    }\n    static init(_x, _y, _state) {\n        // Always start white when manually planted.\n        return {\n            colour: \"white\"\n        };\n    }\n    static _pickColourWeighted(state) {\n        // Weighted palette: common colours show up a lot, rare ones occasionally.\n        // Weights are relative, not percentages.\n        const weighted = [\n            [\n                \"white\",\n                40\n            ],\n            [\n                \"red\",\n                18\n            ],\n            [\n                \"pink\",\n                18\n            ],\n            [\n                \"salmon\",\n                12\n            ],\n            [\n                \"magenta\",\n                10\n            ],\n            [\n                \"purple\",\n                10\n            ],\n            [\n                \"lavender\",\n                10\n            ],\n            [\n                \"orange\",\n                8\n            ],\n            [\n                \"yellow\",\n                8\n            ],\n            [\n                \"peach\",\n                7\n            ],\n            [\n                \"deepblue\",\n                7\n            ],\n            [\n                \"crimson\",\n                6\n            ],\n            [\n                \"scarlet\",\n                6\n            ],\n            [\n                \"hotpink\",\n                5\n            ],\n            [\n                \"violet\",\n                5\n            ],\n            [\n                \"blue\",\n                3\n            ],\n            [\n                \"teal\",\n                2\n            ],\n            [\n                \"black\",\n                1\n            ],\n            [\n                \"gold\",\n                1\n            ]\n        ];\n        let total = 0;\n        for (const [, w] of weighted)total += w;\n        let r = state.rng() * total;\n        for (const [name, w] of weighted){\n            r -= w;\n            if (r <= 0) return name;\n        }\n        return \"white\";\n    }\n    static _colourToRGB(name) {\n        const map = {\n            white: \"rgb(245,245,245)\",\n            red: \"rgb(230,70,70)\",\n            pink: \"rgb(240,120,170)\",\n            salmon: \"rgb(240,140,120)\",\n            magenta: \"rgb(230,90,220)\",\n            purple: \"rgb(160,90,230)\",\n            lavender: \"rgb(210,180,255)\",\n            orange: \"rgb(245,150,70)\",\n            yellow: \"rgb(250,235,90)\",\n            peach: \"rgb(255,190,150)\",\n            deepblue: \"rgb(55, 29, 250)\",\n            crimson: \"rgb(190,40,70)\",\n            scarlet: \"rgb(252, 26, 26)\",\n            hotpink: \"rgb(255,80,200)\",\n            violet: \"rgb(170,110,255)\",\n            blue: \"rgb(90,140,255)\",\n            teal: \"rgb(90,220,210)\",\n            black: \"rgb(30,30,30)\",\n            gold: \"rgb(251, 203, 61)\"\n        };\n        return map[name] || \"rgb(245,245,245)\";\n    }\n    static onTick(x, y, state) {\n        const st = state.plantGrid[y][x];\n        if (!st) return;\n        st.age += 1;\n        if (st.stage < this.maxStage && st.age % 3 === 0) st.stage += 1;\n        // Only spread when mature\n        if (st.stage < this.maxStage) return;\n        if (st.age % 6 !== 0) return;\n        // Local crowd limit\n        const local = this._countPlantsInMoore(this.typeName, x, y, state);\n        if (local >= 3) return;\n        const candidates = (0, $bd02c871d9c5ba8e$export$cb8c62edfcec0fd2)(x, y).filter(([nx, ny])=>(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny));\n        // Shuffle\n        for(let i = candidates.length - 1; i > 0; i--){\n            const j = Math.floor(state.rng() * (i + 1));\n            [candidates[i], candidates[j]] = [\n                candidates[j],\n                candidates[i]\n            ];\n        }\n        // Prefer less crowded targets\n        candidates.sort((a, b)=>{\n            const ca = this._countPlantsInMoore(this.typeName, a[0], a[1], state);\n            const cb = this._countPlantsInMoore(this.typeName, b[0], b[1], state);\n            return ca - cb;\n        });\n        if (state.rng() > 0.55) return;\n        const parentColour = st.data.colour;\n        // Mutation:\n        // - Most of the time inherit\n        // - Sometimes pick a new colour (with rare colours possible)\n        // - White is a bit \"unstable\" so it mutates slightly more often\n        const mutationChance = parentColour === \"white\" ? 0.14 : 0.08;\n        let childColour = parentColour;\n        if (state.rng() < mutationChance) childColour = this._pickColourWeighted(state);\n        for (const [nx, ny] of candidates){\n            if (this._countPlantsInMoore(this.typeName, nx, ny, state) >= 2) continue;\n            if (this._trySpreadTo(this.typeName, x, y, nx, ny, this.canPlantOn, state)) {\n                const child = state.plantGrid[ny][nx];\n                child.data.colour = childColour;\n                break;\n            }\n        }\n    }\n    static draw(ctx, px, py, st) {\n        const cx = px + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        const cy = py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) / 2;\n        // Stem (shorter, thicker than daisy)\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = \"rgb(60,170,90)\";\n        ctx.beginPath();\n        ctx.moveTo(cx, py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 5);\n        ctx.lineTo(cx, cy + 2);\n        ctx.stroke();\n        // Leaves near base (geranium-ish)\n        ctx.fillStyle = \"rgb(70,190,110)\";\n        ctx.beginPath();\n        ctx.ellipse(cx - 4, py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 6, 4, 2, -0.3, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.beginPath();\n        ctx.ellipse(cx + 4, py + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 6, 4, 2, 0.3, 0, Math.PI * 2);\n        ctx.fill();\n        if (st.stage < 1) return;\n        // Flower head: dense cluster of bigger petals\n        const bloomR = 3 + st.stage; // overall size\n        const petalR = 2 + Math.floor(st.stage / 2);\n        const flowerCol = this._colourToRGB(st.data.colour);\n        // Outer petals (6 petals, rounder look)\n        ctx.fillStyle = flowerCol;\n        const pts = [\n            [\n                0,\n                -5\n            ],\n            [\n                4,\n                -3\n            ],\n            [\n                5,\n                0\n            ],\n            [\n                4,\n                3\n            ],\n            [\n                0,\n                5\n            ],\n            [\n                -4,\n                3\n            ],\n            [\n                -5,\n                0\n            ],\n            [\n                -4,\n                -3\n            ]\n        ];\n        for (const [dx, dy] of pts){\n            ctx.beginPath();\n            ctx.arc(cx + dx, cy + dy, petalR, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        // Inner fill to make it look like a single \"ball\" bloom\n        ctx.beginPath();\n        ctx.arc(cx, cy, bloomR, 0, Math.PI * 2);\n        ctx.fill();\n        // Darker centre (geraniums often have a visible core)\n        ctx.fillStyle = \"rgba(0,0,0,0.25)\";\n        ctx.beginPath();\n        ctx.arc(cx, cy, Math.max(2, bloomR - 2), 0, Math.PI * 2);\n        ctx.fill();\n        // Small highlight dot\n        ctx.fillStyle = \"rgba(255,255,255,0.35)\";\n        ctx.beginPath();\n        ctx.arc(cx - 1, cy - 1, 1, 0, Math.PI * 2);\n        ctx.fill();\n    }\n}\n\n\n\n\nclass $84136c0d47d3c86e$export$8c5df996010e4ff2 extends (0, $2bd4c572d50c8c3c$export$72afe9c85ade6759) {\n    static typeName = \"fence\";\n    static displayName = \"Fence\";\n    static maxStage = 0;\n    static canPlantOn(_x, _y, _state) {\n        return true;\n    }\n    static onTick(_x, _y, _state) {}\n    static draw(ctx, px, py, _st) {\n        const x0 = px;\n        const y0 = py;\n        const inset = 3;\n        const top = y0 + 5;\n        const bottom = y0 + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - 4;\n        const leftX = x0 + inset + 2;\n        const rightX = x0 + (0, $ba30e20475feac5a$export$cf9ad17145f68381) - inset - 2;\n        const rail1Y = y0 + 9;\n        const rail2Y = y0 + 14;\n        ctx.fillStyle = \"rgb(170,140,95)\";\n        ctx.strokeStyle = \"rgba(0,0,0,0.9)\";\n        ctx.lineWidth = 1;\n        ctx.fillRect(leftX - 1, top, 3, bottom - top);\n        ctx.fillRect(rightX - 1, top, 3, bottom - top);\n        ctx.fillRect(leftX + 2, rail1Y, rightX - leftX - 3, 3);\n        ctx.fillRect(leftX + 2, rail2Y, rightX - leftX - 3, 3);\n        ctx.fillRect(leftX - 2, top - 2, 5, 3);\n        ctx.fillRect(rightX - 2, top - 2, 5, 3);\n    }\n}\n\n\nconst $ae605652761ddad2$export$853aac19120fead9 = {\n    [(0, $e6d73616bebf33a6$export$e6c4aaad6785574a).typeName]: (0, $e6d73616bebf33a6$export$e6c4aaad6785574a),\n    [(0, $596ac2c908efdf81$export$9a60c84efaf62b31).typeName]: (0, $596ac2c908efdf81$export$9a60c84efaf62b31),\n    [(0, $aee5caf8454147df$export$78990388006fc58f).typeName]: (0, $aee5caf8454147df$export$78990388006fc58f),\n    [(0, $c6a75af8f4fb0994$export$8ac37319d3c8ed52).typeName]: (0, $c6a75af8f4fb0994$export$8ac37319d3c8ed52),\n    [(0, $709369b466786239$export$f19b6aa86008a814).typeName]: (0, $709369b466786239$export$f19b6aa86008a814),\n    [(0, $b0bb96384d34d4b5$export$58ada19cd5f35ee9).typeName]: (0, $b0bb96384d34d4b5$export$58ada19cd5f35ee9),\n    [(0, $b8a2607e32fe05cd$export$b4a25d14236c1d1b).typeName]: (0, $b8a2607e32fe05cd$export$b4a25d14236c1d1b),\n    [(0, $bd8aba2dd7d109a5$export$6c157b3ee5a67478).typeName]: (0, $bd8aba2dd7d109a5$export$6c157b3ee5a67478),\n    [(0, $a91a379d18c4a638$export$b75a6b61dc760dd5).typeName]: (0, $a91a379d18c4a638$export$b75a6b61dc760dd5),\n    [(0, $910dbe2a5f197a40$export$aad56179aff78418).typeName]: (0, $910dbe2a5f197a40$export$aad56179aff78418),\n    [(0, $84136c0d47d3c86e$export$8c5df996010e4ff2).typeName]: (0, $84136c0d47d3c86e$export$8c5df996010e4ff2)\n};\nconst $ae605652761ddad2$export$37c4892f14cb3149 = [\n    (0, $596ac2c908efdf81$export$9a60c84efaf62b31).typeName,\n    (0, $e6d73616bebf33a6$export$e6c4aaad6785574a).typeName,\n    (0, $aee5caf8454147df$export$78990388006fc58f).typeName,\n    (0, $c6a75af8f4fb0994$export$8ac37319d3c8ed52).typeName,\n    (0, $709369b466786239$export$f19b6aa86008a814).typeName,\n    (0, $b8a2607e32fe05cd$export$b4a25d14236c1d1b).typeName,\n    (0, $bd8aba2dd7d109a5$export$6c157b3ee5a67478).typeName,\n    (0, $a91a379d18c4a638$export$b75a6b61dc760dd5).typeName,\n    (0, $910dbe2a5f197a40$export$aad56179aff78418).typeName,\n    (0, $b0bb96384d34d4b5$export$58ada19cd5f35ee9).typeName,\n    (0, $84136c0d47d3c86e$export$8c5df996010e4ff2).typeName\n];\nconst $ae605652761ddad2$export$b1ef01852a007257 = {\n    daisy: 30,\n    reed: 40,\n    cactus: 50,\n    chromatic: 80,\n    wanderer: 120,\n    blight: 200,\n    fence: 1,\n    mushroom: 60,\n    lichen: 40,\n    geranium: 60,\n    lily: 80\n};\n\n\n\nfunction $ce3de23872348272$export$de5e90bd767c5d82() {\n    return {\n        baseGrid: (0, $29289ae2f853543e$export$b73337e033eb9f1f)(\"grass\"),\n        plantGrid: (0, $29289ae2f853543e$export$39c1b8934bddc9a6)(),\n        selectedTool: \"tile\",\n        selectedValue: \"grass\",\n        paused: false,\n        showGrid: true,\n        seedCounter: 1,\n        rng: (0, $bd02c871d9c5ba8e$export$d22a027dada4117a)(123456),\n        magic: (0, $ba30e20475feac5a$export$555041af39b08b54)\n    };\n}\nfunction $ce3de23872348272$export$1042faa6df30c26(state) {\n    let refund = 0;\n    for(let y = 0; y < state.plantGrid.length; y++){\n        const row = state.plantGrid[y];\n        for(let x = 0; x < row.length; x++){\n            const st = row[x];\n            if (!st) continue;\n            const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[st.plantType];\n            if (!cls) continue;\n            if (st.stage === cls.maxStage) refund += Math.ceil((0, $ae605652761ddad2$export$b1ef01852a007257)[st.plantType] / 10);\n        }\n    }\n    state.plantGrid = (0, $29289ae2f853543e$export$39c1b8934bddc9a6)();\n    state.magic += refund;\n}\n\n\n\n\n\nfunction $fb876e5b585dc157$export$fb931cd598921492(state) {\n    const data = {\n        w: (0, $ba30e20475feac5a$export$5ea37ee797880001),\n        h: (0, $ba30e20475feac5a$export$5613db76819ec00b),\n        base: state.baseGrid,\n        plants: state.plantGrid,\n        magic: state.magic\n    };\n    localStorage.setItem((0, $ba30e20475feac5a$export$315a7bb69757d5a7), JSON.stringify(data));\n}\nfunction $fb876e5b585dc157$export$ea32cbdd559da174(state) {\n    const raw = localStorage.getItem((0, $ba30e20475feac5a$export$315a7bb69757d5a7));\n    if (!raw) return;\n    try {\n        const data = JSON.parse(raw);\n        if (Array.isArray(data.base) && data.base.length === (0, $ba30e20475feac5a$export$5613db76819ec00b)) for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++){\n            const row = data.base[y];\n            if (!Array.isArray(row) || row.length !== (0, $ba30e20475feac5a$export$5ea37ee797880001)) continue;\n            for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n                const v = row[x];\n                state.baseGrid[y][x] = (0, $ba30e20475feac5a$export$34ddeca23ac38a20).includes(v) ? v : \"grass\";\n            }\n        }\n        if (Array.isArray(data.plants) && data.plants.length === (0, $ba30e20475feac5a$export$5613db76819ec00b)) for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++){\n            const row = data.plants[y];\n            if (!Array.isArray(row) || row.length !== (0, $ba30e20475feac5a$export$5ea37ee797880001)) continue;\n            for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n                const cell = row[x];\n                if (cell === null) {\n                    state.plantGrid[y][x] = null;\n                    continue;\n                }\n                if (!cell || typeof cell !== \"object\") {\n                    state.plantGrid[y][x] = null;\n                    continue;\n                }\n                const pt = cell.plantType;\n                if (!pt || !(0, $ae605652761ddad2$export$853aac19120fead9)[pt]) {\n                    state.plantGrid[y][x] = null;\n                    continue;\n                }\n                state.plantGrid[y][x] = {\n                    plantType: pt,\n                    stage: (0, $bd02c871d9c5ba8e$export$7d15b64cf5a3a4c4)(cell.stage | 0, 0, 99),\n                    age: (0, $bd02c871d9c5ba8e$export$7d15b64cf5a3a4c4)(cell.age | 0, 0, 999999),\n                    data: cell.data\n                };\n            }\n        }\n        if (typeof data.magic === \"number\") state.magic = Math.max(0, Math.floor(data.magic));\n    } catch (e) {\n    // ignore\n    }\n}\n\n\n\n\n\n\n\n\nfunction $0e3ac76a52ae2277$var$randInt(rng, min, maxInclusive) {\n    return min + Math.floor(rng() * (maxInclusive - min + 1));\n}\nfunction $0e3ac76a52ae2277$var$cloneGrid(grid) {\n    const out = [];\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)out.push(grid[y].slice());\n    return out;\n}\nfunction $0e3ac76a52ae2277$var$count8(grid, x, y, tileType) {\n    let n = 0;\n    for(let dy = -1; dy <= 1; dy++)for(let dx = -1; dx <= 1; dx++){\n        if (dx === 0 && dy === 0) continue;\n        const nx = x + dx;\n        const ny = y + dy;\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n        if (grid[ny][nx] === tileType) n++;\n    }\n    return n;\n}\nfunction $0e3ac76a52ae2277$var$count4(grid, x, y, tileType) {\n    let n = 0;\n    const dirs = [\n        [\n            1,\n            0\n        ],\n        [\n            -1,\n            0\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            0,\n            -1\n        ]\n    ];\n    for (const [dx, dy] of dirs){\n        const nx = x + dx;\n        const ny = y + dy;\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n        if (grid[ny][nx] === tileType) n++;\n    }\n    return n;\n}\nfunction $0e3ac76a52ae2277$var$randomWalkCarve(rng, grid, tileType, startX, startY, steps, brushRadius) {\n    let x = startX;\n    let y = startY;\n    const dirs = [\n        [\n            1,\n            0\n        ],\n        [\n            -1,\n            0\n        ],\n        [\n            0,\n            1\n        ],\n        [\n            0,\n            -1\n        ]\n    ];\n    for(let i = 0; i < steps; i++){\n        // Carve with a brush\n        for(let by = -brushRadius; by <= brushRadius; by++)for(let bx = -brushRadius; bx <= brushRadius; bx++){\n            const nx = x + bx;\n            const ny = y + by;\n            if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n            // Circle-ish brush\n            if (bx * bx + by * by > brushRadius * brushRadius) continue;\n            grid[ny][nx] = tileType;\n        }\n        // Step with slight momentum\n        const [dx, dy] = dirs[$0e3ac76a52ae2277$var$randInt(rng, 0, dirs.length - 1)];\n        x = Math.max(1, Math.min((0, $ba30e20475feac5a$export$5ea37ee797880001) - 2, x + dx));\n        y = Math.max(1, Math.min((0, $ba30e20475feac5a$export$5613db76819ec00b) - 2, y + dy));\n        // Occasionally change brush size slightly to avoid perfect blobs\n        if (rng() < 0.12) brushRadius = Math.max(1, Math.min(3, brushRadius + (rng() < 0.5 ? -1 : 1)));\n    }\n}\nfunction $0e3ac76a52ae2277$var$paintRingsAroundWater(rng, grid) {\n    // First pass: sand around water\n    const next = $0e3ac76a52ae2277$var$cloneGrid(grid);\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n        if (grid[y][x] !== \"grass\") continue;\n        const nearWater = $0e3ac76a52ae2277$var$count8(grid, x, y, \"water\");\n        if (nearWater >= 1 && rng() < 0.85) next[y][x] = \"sand\";\n    }\n    // Second pass: mud around water (and sometimes around sand)\n    const next2 = $0e3ac76a52ae2277$var$cloneGrid(next);\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n        if (next[y][x] !== \"grass\" && next[y][x] !== \"sand\") continue;\n        const nearWater = $0e3ac76a52ae2277$var$count8(next, x, y, \"water\");\n        const nearSand = $0e3ac76a52ae2277$var$count8(next, x, y, \"sand\");\n        // Mud is more patchy than sand\n        if (nearWater >= 1 && rng() < 0.45) next2[y][x] = \"mud\";\n        else if (nearSand >= 3 && rng() < 0.22) next2[y][x] = \"mud\";\n    }\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++)grid[y][x] = next2[y][x];\n}\nfunction $0e3ac76a52ae2277$var$growStoneClusters(rng, grid) {\n    // Place a few seeds, then grow outward like lichen/rock outcrops.\n    const seeds = $0e3ac76a52ae2277$var$randInt(rng, 2, 4);\n    const frontier = [];\n    for(let i = 0; i < seeds; i++){\n        const x = $0e3ac76a52ae2277$var$randInt(rng, 0, (0, $ba30e20475feac5a$export$5ea37ee797880001) - 1);\n        const y = $0e3ac76a52ae2277$var$randInt(rng, 0, (0, $ba30e20475feac5a$export$5613db76819ec00b) - 1);\n        // Avoid dumping stone on top of water/beaches\n        if (grid[y][x] === \"water\") continue;\n        if ($0e3ac76a52ae2277$var$count8(grid, x, y, \"water\") > 0) continue;\n        grid[y][x] = \"stone\";\n        frontier.push([\n            x,\n            y\n        ]);\n    }\n    // Growth steps\n    const steps = $0e3ac76a52ae2277$var$randInt(rng, 35, 70);\n    for(let i = 0; i < steps; i++){\n        if (frontier.length === 0) break;\n        const idx = $0e3ac76a52ae2277$var$randInt(rng, 0, frontier.length - 1);\n        const [fx, fy] = frontier[idx];\n        const dirs = [\n            [\n                1,\n                0\n            ],\n            [\n                -1,\n                0\n            ],\n            [\n                0,\n                1\n            ],\n            [\n                0,\n                -1\n            ],\n            [\n                1,\n                1\n            ],\n            [\n                1,\n                -1\n            ],\n            [\n                -1,\n                1\n            ],\n            [\n                -1,\n                -1\n            ]\n        ];\n        const [dx, dy] = dirs[$0e3ac76a52ae2277$var$randInt(rng, 0, dirs.length - 1)];\n        const nx = fx + dx;\n        const ny = fy + dy;\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(nx, ny)) continue;\n        if (grid[ny][nx] !== \"grass\") continue;\n        // Stone prefers to grow near stone, but not endlessly.\n        const nearStone = $0e3ac76a52ae2277$var$count8(grid, nx, ny, \"stone\");\n        const nearWater = $0e3ac76a52ae2277$var$count8(grid, nx, ny, \"water\");\n        if (nearWater > 0) continue;\n        const chance = 0.20 + nearStone * 0.12; // 0.32.. etc\n        if (rng() < chance) {\n            grid[ny][nx] = \"stone\";\n            frontier.push([\n                nx,\n                ny\n            ]);\n        }\n        // Occasionally prune the frontier so it doesn't explode\n        if (frontier.length > 120 && rng() < 0.25) frontier.splice(idx, 1);\n    }\n}\nfunction $0e3ac76a52ae2277$var$cleanupSpeckles(rng, grid) {\n    // Remove lonely single tiles (especially sand/mud/stone dots)\n    const next = $0e3ac76a52ae2277$var$cloneGrid(grid);\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n        const t = grid[y][x];\n        if (t === \"water\") continue;\n        const same = $0e3ac76a52ae2277$var$count8(grid, x, y, t);\n        // If a tile has basically no support, nudge it back to grass.\n        if ((t === \"sand\" || t === \"mud\" || t === \"stone\") && same <= 1) {\n            // But keep beaches if they are near water\n            const nearWater = $0e3ac76a52ae2277$var$count8(grid, x, y, \"water\");\n            if (nearWater >= 2) continue;\n            if (rng() < 0.85) next[y][x] = \"grass\";\n        }\n        // If grass is surrounded by water, convert it to water (fills holes)\n        if (t === \"grass\") {\n            const waterN = $0e3ac76a52ae2277$var$count8(grid, x, y, \"water\");\n            if (waterN >= 6 && rng() < 0.40) next[y][x] = \"water\";\n        }\n    }\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++)grid[y][x] = next[y][x];\n}\nfunction $0e3ac76a52ae2277$export$ae8c9f3c07d89ec0(rng, baseGrid) {\n    // 0) Start grass\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++)baseGrid[y][x] = \"grass\";\n    // 1) One main lake\n    {\n        const sx = $0e3ac76a52ae2277$var$randInt(rng, Math.floor((0, $ba30e20475feac5a$export$5ea37ee797880001) * 0.25), Math.floor((0, $ba30e20475feac5a$export$5ea37ee797880001) * 0.75));\n        const sy = $0e3ac76a52ae2277$var$randInt(rng, Math.floor((0, $ba30e20475feac5a$export$5613db76819ec00b) * 0.25), Math.floor((0, $ba30e20475feac5a$export$5613db76819ec00b) * 0.75));\n        const steps = $0e3ac76a52ae2277$var$randInt(rng, 55, 85);\n        const brush = $0e3ac76a52ae2277$var$randInt(rng, 2, 3);\n        $0e3ac76a52ae2277$var$randomWalkCarve(rng, baseGrid, \"water\", sx, sy, steps, brush);\n    }\n    // 2) Sometimes add a smaller pond\n    if (rng() < 0.55) {\n        const sx = $0e3ac76a52ae2277$var$randInt(rng, 2, (0, $ba30e20475feac5a$export$5ea37ee797880001) - 3);\n        const sy = $0e3ac76a52ae2277$var$randInt(rng, 2, (0, $ba30e20475feac5a$export$5613db76819ec00b) - 3);\n        const steps = $0e3ac76a52ae2277$var$randInt(rng, 18, 35);\n        const brush = $0e3ac76a52ae2277$var$randInt(rng, 1, 2);\n        $0e3ac76a52ae2277$var$randomWalkCarve(rng, baseGrid, \"water\", sx, sy, steps, brush);\n    }\n    // 3) Add sand + mud around water\n    $0e3ac76a52ae2277$var$paintRingsAroundWater(rng, baseGrid);\n    // 4) Grow stone outcrops away from water\n    $0e3ac76a52ae2277$var$growStoneClusters(rng, baseGrid);\n    // 5) A bit of cleanup\n    $0e3ac76a52ae2277$var$cleanupSpeckles(rng, baseGrid);\n    // 6) Extra tiny touch: a few mud pockets in grassy lowlands\n    // (adds variety without ruining readability)\n    for(let i = 0; i < 20; i++){\n        const x = $0e3ac76a52ae2277$var$randInt(rng, 0, (0, $ba30e20475feac5a$export$5ea37ee797880001) - 1);\n        const y = $0e3ac76a52ae2277$var$randInt(rng, 0, (0, $ba30e20475feac5a$export$5613db76819ec00b) - 1);\n        if (baseGrid[y][x] !== \"grass\") continue;\n        if ($0e3ac76a52ae2277$var$count8(baseGrid, x, y, \"water\") > 0) continue;\n        if ($0e3ac76a52ae2277$var$count8(baseGrid, x, y, \"stone\") > 0) continue;\n        if (rng() < 0.15) baseGrid[y][x] = \"mud\";\n    }\n    // Optional: soften isolated mud dots a bit\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n        if (baseGrid[y][x] !== \"mud\") continue;\n        if ($0e3ac76a52ae2277$var$count4(baseGrid, x, y, \"mud\") === 0 && rng() < 0.70) baseGrid[y][x] = \"grass\";\n    }\n}\n\n\nfunction $f9a85cdfa1754a18$export$1b8933bdb9567194(count) {\n    const magicCount = document.getElementById(\"magicCount\");\n    magicCount.textContent = String(count);\n}\nfunction $f9a85cdfa1754a18$export$86a308b97e5e5308(state, canvas) {\n    const tileButtons = document.getElementById(\"tileButtons\");\n    const seedButtons = document.getElementById(\"seedButtons\");\n    const tickPill = document.getElementById(\"tickPill\");\n    const gridPill = document.getElementById(\"gridPill\");\n    const magicCount = document.getElementById(\"magicCount\");\n    const inspector = document.getElementById(\"inspector\");\n    function makeButton(label, kind, value, swatchColour, cost) {\n        const b = document.createElement(\"div\");\n        b.className = \"btn\";\n        b.dataset.kind = kind;\n        b.dataset.value = value;\n        if (swatchColour) {\n            const s = document.createElement(\"div\");\n            s.className = \"swatch\";\n            s.style.background = swatchColour;\n            b.appendChild(s);\n        }\n        const t = document.createElement(\"div\");\n        t.textContent = label;\n        b.appendChild(t);\n        if (typeof cost === \"number\") {\n            const c = document.createElement(\"div\");\n            c.className = \"cost\";\n            c.textContent = `${cost}\\u{1D4DC}`;\n            b.appendChild(c);\n        }\n        b.addEventListener(\"click\", ()=>{\n            state.selectedTool = kind;\n            state.selectedValue = value;\n            refreshButtons();\n        });\n        return b;\n    }\n    const tileBtnEls = [];\n    for (const t of (0, $ba30e20475feac5a$export$34ddeca23ac38a20)){\n        const el = makeButton(t, \"tile\", t, (0, $ba30e20475feac5a$export$619b51fcfd7c4956)[t], 1);\n        tileButtons.appendChild(el);\n        tileBtnEls.push(el);\n    }\n    const seedBtnEls = [];\n    for (const s of (0, $ae605652761ddad2$export$37c4892f14cb3149)){\n        const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[s];\n        const cost = (0, $ae605652761ddad2$export$b1ef01852a007257)[s] ?? 1;\n        const el = makeButton(cls.displayName, \"seed\", s, null, cost);\n        seedButtons.appendChild(el);\n        seedBtnEls.push(el);\n    }\n    function refreshButtons() {\n        for (const el of tileBtnEls){\n            const isSel = state.selectedTool === \"tile\" && state.selectedValue === el.dataset.value;\n            el.classList.toggle(\"selected\", isSel);\n        }\n        for (const el of seedBtnEls){\n            const isSel = state.selectedTool === \"seed\" && state.selectedValue === el.dataset.value;\n            el.classList.toggle(\"selected\", isSel);\n        }\n        tickPill.textContent = `Tick: ${state.paused ? \"paused\" : \"running\"}`;\n        gridPill.textContent = `Grid: ${state.showGrid ? \"on\" : \"off\"}`;\n        magicCount.textContent = String(state.magic);\n    }\n    refreshButtons();\n    canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    function getGridPosFromEvent(e) {\n        const rect = canvas.getBoundingClientRect();\n        const mx = e.clientX - rect.left;\n        const my = e.clientY - rect.top;\n        const gx = Math.floor(mx / (0, $ba30e20475feac5a$export$cf9ad17145f68381));\n        const gy = Math.floor(my / (0, $ba30e20475feac5a$export$cf9ad17145f68381));\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(gx, gy)) return null;\n        return [\n            gx,\n            gy\n        ];\n    }\n    function applyToolAt(gx, gy, button) {\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(gx, gy)) return;\n        if (button === 2) {\n            const st = state.plantGrid[gy][gx];\n            if (st) {\n                const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[st.plantType];\n                // Only reward if the plant is fully grown\n                if (cls && st.stage === cls.maxStage) state.magic += Math.ceil((0, $ae605652761ddad2$export$b1ef01852a007257)[st.plantType] / 10);\n                state.plantGrid[gy][gx] = null;\n                $f9a85cdfa1754a18$export$1b8933bdb9567194(state.magic);\n            }\n            return;\n        }\n        if (button !== 0) return;\n        if (state.selectedTool === \"tile\" && (0, $ba30e20475feac5a$export$34ddeca23ac38a20).includes(state.selectedValue)) {\n            // Don't charge if you're painting the same tile type\n            if (state.baseGrid[gy][gx] !== state.selectedValue) {\n                if (state.magic < 1) return;\n                state.magic -= 1;\n                magicCount.textContent = String(state.magic);\n            }\n            state.baseGrid[gy][gx] = state.selectedValue;\n            const st = state.plantGrid[gy][gx];\n            if (st) {\n                const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[st.plantType];\n                if (cls && !cls.canPlantOn(gx, gy, state)) state.plantGrid[gy][gx] = null;\n            }\n            return;\n        }\n        if (state.selectedTool === \"seed\" && (0, $ae605652761ddad2$export$853aac19120fead9)[state.selectedValue]) {\n            if (state.plantGrid[gy][gx]) return;\n            const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[state.selectedValue];\n            if (!cls.canPlantOn(gx, gy, state)) return;\n            const cost = (0, $ae605652761ddad2$export$b1ef01852a007257)[state.selectedValue] ?? 1;\n            if (state.magic < cost) return;\n            state.magic -= cost;\n            magicCount.textContent = String(state.magic);\n            cls.plant(gx, gy, state);\n        }\n    }\n    function setInspector(text) {\n        if (!inspector) return;\n        inspector.textContent = text || \"\";\n    }\n    function describeCell(gx, gy) {\n        if (!(0, $bd02c871d9c5ba8e$export$4e985c1b25c164db)(gx, gy)) return \"\";\n        const st = state.plantGrid[gy][gx];\n        if (!st) return \"\";\n        const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[st.plantType];\n        if (!cls) return \"\";\n        if (typeof cls.getDescription === \"function\") return cls.getDescription(gx, gy, state);\n        return cls.displayName;\n    }\n    let dragging = false;\n    let dragButton = 0;\n    let lastCellKey = null;\n    let lastInspectKey = null;\n    canvas.addEventListener(\"mousemove\", (e)=>{\n        const gp = getGridPosFromEvent(e);\n        if (!gp) {\n            if (lastInspectKey !== null) {\n                lastInspectKey = null;\n                setInspector(\"\");\n            }\n            return;\n        }\n        const [gx, gy] = gp;\n        const key = `${gx},${gy}`;\n        if (key === lastInspectKey) return;\n        lastInspectKey = key;\n        setInspector(describeCell(gx, gy));\n    });\n    canvas.addEventListener(\"mouseleave\", ()=>{\n        lastInspectKey = null;\n        setInspector(\"\");\n    });\n    canvas.addEventListener(\"mousedown\", (e)=>{\n        const gp = getGridPosFromEvent(e);\n        if (!gp) return;\n        dragging = true;\n        dragButton = e.button;\n        lastCellKey = null;\n        const [gx, gy] = gp;\n        applyToolAt(gx, gy, dragButton);\n        lastCellKey = `${gx},${gy}`;\n    });\n    window.addEventListener(\"mouseup\", ()=>{\n        dragging = false;\n        lastCellKey = null;\n    });\n    canvas.addEventListener(\"mousemove\", (e)=>{\n        if (!dragging) return;\n        const gp = getGridPosFromEvent(e);\n        if (!gp) return;\n        const [gx, gy] = gp;\n        const key = `${gx},${gy}`;\n        if (key === lastCellKey) return;\n        applyToolAt(gx, gy, dragButton);\n        lastCellKey = key;\n    });\n    window.addEventListener(\"keydown\", (e)=>{\n        if (e.repeat) return;\n        if (e.key === \"c\" || e.key === \"C\") (0, $ce3de23872348272$export$1042faa6df30c26)(state);\n        else if (e.key === \"r\" || e.key === \"R\") {\n            (0, $ce3de23872348272$export$1042faa6df30c26)(state);\n            (0, $0e3ac76a52ae2277$export$ae8c9f3c07d89ec0)(state.rng, state.baseGrid);\n        } else if (e.key === \"o\" || e.key === \"O\") {\n            (0, $ce3de23872348272$export$1042faa6df30c26)(state);\n            (0, $0e3ac76a52ae2277$export$ae8c9f3c07d89ec0)(state.rng, state.baseGrid);\n            state.magic = (0, $ba30e20475feac5a$export$555041af39b08b54);\n        } else if (e.key === \"g\" || e.key === \"G\") state.showGrid = !state.showGrid;\n        else if (e.key === \" \") state.paused = !state.paused;\n        refreshButtons();\n    });\n    return {\n        refreshButtons: refreshButtons\n    };\n}\n\n\n\n\n\nfunction $2087aa9fd3bb8bd6$export$913ee38534458e53(state) {\n    const coords = [];\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++){\n        for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++)if (state.plantGrid[y][x]) coords.push([\n            x,\n            y\n        ]);\n    }\n    state.rng = (0, $bd02c871d9c5ba8e$export$d22a027dada4117a)(Date.now() + state.seedCounter & 0xffffffff);\n    state.seedCounter++;\n    for (const [x, y] of coords){\n        const st = state.plantGrid[y][x];\n        if (!st) continue;\n        const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[st.plantType];\n        if (!cls) {\n            state.plantGrid[y][x] = null;\n            continue;\n        }\n        if (!cls.canPlantOn(x, y, state)) {\n            state.plantGrid[y][x] = null;\n            continue;\n        }\n        cls.onTick(x, y, state);\n    }\n}\n\n\n\n\nfunction $7fdb1a51114ea38b$export$5e145c486af18f03(state, ctx) {\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n        ctx.fillStyle = (0, $ba30e20475feac5a$export$619b51fcfd7c4956)[state.baseGrid[y][x]] || \"#777\";\n        ctx.fillRect(x * (0, $ba30e20475feac5a$export$cf9ad17145f68381), y * (0, $ba30e20475feac5a$export$cf9ad17145f68381), (0, $ba30e20475feac5a$export$cf9ad17145f68381), (0, $ba30e20475feac5a$export$cf9ad17145f68381));\n    }\n    if (state.showGrid) {\n        ctx.strokeStyle = (0, $ba30e20475feac5a$export$4f193d7d85690f47).gridLine;\n        ctx.lineWidth = 1;\n        for(let x = 0; x <= (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n            const px = x * (0, $ba30e20475feac5a$export$cf9ad17145f68381) + 0.5;\n            ctx.beginPath();\n            ctx.moveTo(px, 0);\n            ctx.lineTo(px, (0, $ba30e20475feac5a$export$5613db76819ec00b) * (0, $ba30e20475feac5a$export$cf9ad17145f68381));\n            ctx.stroke();\n        }\n        for(let y = 0; y <= (0, $ba30e20475feac5a$export$5613db76819ec00b); y++){\n            const py = y * (0, $ba30e20475feac5a$export$cf9ad17145f68381) + 0.5;\n            ctx.beginPath();\n            ctx.moveTo(0, py);\n            ctx.lineTo((0, $ba30e20475feac5a$export$5ea37ee797880001) * (0, $ba30e20475feac5a$export$cf9ad17145f68381), py);\n            ctx.stroke();\n        }\n    }\n    for(let y = 0; y < (0, $ba30e20475feac5a$export$5613db76819ec00b); y++)for(let x = 0; x < (0, $ba30e20475feac5a$export$5ea37ee797880001); x++){\n        const st = state.plantGrid[y][x];\n        if (!st) continue;\n        const cls = (0, $ae605652761ddad2$export$853aac19120fead9)[st.plantType];\n        if (!cls) continue;\n        cls.draw(ctx, x * (0, $ba30e20475feac5a$export$cf9ad17145f68381), y * (0, $ba30e20475feac5a$export$cf9ad17145f68381), st);\n    }\n}\n\n\n\nconst $54b47fc030b7b21e$var$state = (0, $ce3de23872348272$export$de5e90bd767c5d82)();\n(0, $0e3ac76a52ae2277$export$ae8c9f3c07d89ec0)($54b47fc030b7b21e$var$state.rng, $54b47fc030b7b21e$var$state.baseGrid);\nconst $54b47fc030b7b21e$var$canvas = document.getElementById(\"game\");\nconst $54b47fc030b7b21e$var$ctx = $54b47fc030b7b21e$var$canvas.getContext(\"2d\");\n$54b47fc030b7b21e$var$canvas.width = (0, $ba30e20475feac5a$export$5ea37ee797880001) * (0, $ba30e20475feac5a$export$cf9ad17145f68381);\n$54b47fc030b7b21e$var$canvas.height = (0, $ba30e20475feac5a$export$5613db76819ec00b) * (0, $ba30e20475feac5a$export$cf9ad17145f68381);\nconst { refreshButtons: $54b47fc030b7b21e$var$refreshButtons } = (0, $f9a85cdfa1754a18$export$86a308b97e5e5308)($54b47fc030b7b21e$var$state, $54b47fc030b7b21e$var$canvas);\n(0, $fb876e5b585dc157$export$ea32cbdd559da174)($54b47fc030b7b21e$var$state);\n$54b47fc030b7b21e$var$refreshButtons();\nsetInterval(()=>{\n    if (!$54b47fc030b7b21e$var$state.paused) {\n        (0, $2087aa9fd3bb8bd6$export$913ee38534458e53)($54b47fc030b7b21e$var$state);\n        (0, $f9a85cdfa1754a18$export$1b8933bdb9567194)($54b47fc030b7b21e$var$state.magic);\n    }\n}, (0, $ba30e20475feac5a$export$4b203929188df7d1));\nfunction $54b47fc030b7b21e$var$loop() {\n    (0, $7fdb1a51114ea38b$export$5e145c486af18f03)($54b47fc030b7b21e$var$state, $54b47fc030b7b21e$var$ctx);\n    requestAnimationFrame($54b47fc030b7b21e$var$loop);\n}\n$54b47fc030b7b21e$var$loop();\nwindow.addEventListener(\"beforeunload\", ()=>{\n    (0, $fb876e5b585dc157$export$fb931cd598921492)($54b47fc030b7b21e$var$state);\n});\n\n\n//# sourceMappingURL=garden.a47efa89.js.map\n","import { GRID_W, GRID_H, TILE_SIZE, TICK_MS } from \"./config.js\";\nimport { createInitialState } from \"./state.js\";\nimport { loadState, saveState } from \"./save.js\";\nimport { setupUI, updateMagicCount } from \"./ui.js\";\nimport { tickPlants } from \"./tick.js\";\nimport { drawFrame } from \"./render.js\";\nimport { generateNaturalBaseGrid } from \"./terrain.js\";\n\nconst state = createInitialState();\ngenerateNaturalBaseGrid(state.rng, state.baseGrid);\n\nconst canvas = document.getElementById(\"game\");\nconst ctx = canvas.getContext(\"2d\");\n\ncanvas.width = GRID_W * TILE_SIZE;\ncanvas.height = GRID_H * TILE_SIZE;\n\nconst { refreshButtons } = setupUI(state, canvas);\n\nloadState(state);\nrefreshButtons();\n\nsetInterval(() => {\n    if (!state.paused) {\n        tickPlants(state);\n        updateMagicCount(state.magic);\n    }\n}, TICK_MS);\n\nfunction loop() {\n    drawFrame(state, ctx);\n    requestAnimationFrame(loop);\n}\nloop();\n\nwindow.addEventListener(\"beforeunload\", () => {\n    saveState(state);\n});\n","export const TILE_SIZE = 20;\r\nexport const GRID_W = 40;\r\nexport const GRID_H = 30;\r\n\r\nexport const SAVE_KEY = \"tiny_garden_save_v1\";\r\nexport const TICK_MS = 1000;\r\n\r\nexport const TILES = [\"mud\", \"grass\", \"water\", \"sand\", \"stone\"];\r\n\r\nexport const TILE_COLOURS = {\r\n    mud: \"#604834\",\r\n    grass: \"#448c4a\",\r\n    water: \"#3860a4\",\r\n    sand: \"#c6b670\",\r\n    stone: \"#aaaaaa\"\r\n};\r\n\r\nexport const COLOUR = {\r\n    gridLine: \"rgba(0,0,0,0.65)\",\r\n};\r\n\r\nexport const INIT_MAGIC = 1000;\r\n","import { makeBaseGrid, makePlantGrid } from \"./grid.js\";\r\nimport { mulberry32 } from \"./helpers.js\";\r\nimport { PLANT_REGISTRY, SEED_COSTS } from \"./plants/registry.js\";\r\nimport { INIT_MAGIC } from \"./config.js\"\r\n\r\nexport function createInitialState() {\r\n    return {\r\n        baseGrid: makeBaseGrid(\"grass\"),\r\n        plantGrid: makePlantGrid(),\r\n\r\n        selectedTool: \"tile\",\r\n        selectedValue: \"grass\",\r\n\r\n        paused: false,\r\n        showGrid: true,\r\n\r\n        seedCounter: 1,\r\n        rng: mulberry32(123456),\r\n\r\n        magic: INIT_MAGIC,\r\n    };\r\n}\r\n\r\nexport function clearAll(state) {\r\n    let refund = 0;\r\n\r\n    for (let y = 0; y < state.plantGrid.length; y++) {\r\n        const row = state.plantGrid[y];\r\n        for (let x = 0; x < row.length; x++) {\r\n            const st = row[x];\r\n            if (!st) continue;\r\n\r\n            const cls = PLANT_REGISTRY[st.plantType];\r\n            if (!cls) continue;\r\n\r\n            if (st.stage === cls.maxStage) {\r\n                refund += Math.ceil(SEED_COSTS[st.plantType] / 10);\r\n            }\r\n        }\r\n    }\r\n\r\n    state.plantGrid = makePlantGrid();\r\n\r\n    state.magic += refund;\r\n}\r\n","import { GRID_W, GRID_H } from \"./config.js\";\r\n\r\nexport function makeBaseGrid(fill) {\r\n    const g = [];\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        const row = [];\r\n        for (let x = 0; x < GRID_W; x++) row.push(fill);\r\n        g.push(row);\r\n    }\r\n    return g;\r\n}\r\n\r\nexport function makePlantGrid() {\r\n    const g = [];\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        const row = [];\r\n        for (let x = 0; x < GRID_W; x++) row.push(null);\r\n        g.push(row);\r\n    }\r\n    return g;\r\n}\r\n","import { GRID_W, GRID_H } from \"./config.js\";\r\n\r\nexport function inBounds(x, y) {\r\n    return x >= 0 && x < GRID_W && y >= 0 && y < GRID_H;\r\n}\r\n\r\nexport function neighbours4(x, y) {\r\n    return [\r\n        [x + 1, y],\r\n        [x - 1, y],\r\n        [x, y + 1],\r\n        [x, y - 1],\r\n    ];\r\n}\r\n\r\nexport function neighbours8(x, y) {\r\n    const out = [];\r\n    for (let dy = -1; dy <= 1; dy++) {\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            if (dx === 0 && dy === 0) continue;\r\n            out.push([x + dx, y + dy]);\r\n        }\r\n    }\r\n    return out;\r\n}\r\n\r\nexport function choice(rng, arr) {\r\n    return arr[Math.floor(rng() * arr.length)];\r\n}\r\n\r\nexport function clamp(v, a, b) {\r\n    return Math.max(a, Math.min(b, v));\r\n}\r\n\r\nexport function mulberry32(seed) {\r\n    let t = seed >>> 0;\r\n    return function() {\r\n        t += 0x6D2B79F5;\r\n        let x = t;\r\n        x = Math.imul(x ^ (x >>> 15), x | 1);\r\n        x ^= x + Math.imul(x ^ (x >>> 7), x | 61);\r\n        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\n\r\nexport function roundRect(ctx, x, y, w, h, r) {\r\n    const rr = clamp(r, 0, Math.min(w, h) / 2);\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + rr, y);\r\n    ctx.arcTo(x + w, y, x + w, y + h, rr);\r\n    ctx.arcTo(x + w, y + h, x, y + h, rr);\r\n    ctx.arcTo(x, y + h, x, y, rr);\r\n    ctx.arcTo(x, y, x + w, y, rr);\r\n    ctx.closePath();\r\n}\r\n","import { Reed } from \"./Reed.js\";\r\nimport { Daisy } from \"./Daisy.js\";\r\nimport { Cactus } from \"./Cactus.js\";\r\nimport { Chromatic } from \"./Chromatic.js\";\r\nimport { Wandering } from \"./Wandering.js\";\r\nimport { Blight } from \"./Blight.js\";\r\nimport { Mushroom } from \"./Mushroom.js\";\r\nimport { Lichen } from \"./Lichen.js\";\r\nimport { Lily } from \"./Lily.js\";\r\nimport { Geranium } from \"./Geranium.js\";\r\nimport { Fence } from \"./Fence.js\";\r\n\r\nexport const PLANT_REGISTRY = {\r\n    [Reed.typeName]: Reed,\r\n    [Daisy.typeName]: Daisy,\r\n    [Cactus.typeName]: Cactus,\r\n    [Chromatic.typeName]: Chromatic,\r\n    [Wandering.typeName]: Wandering,\r\n    [Blight.typeName]: Blight,\r\n    [Mushroom.typeName]: Mushroom,\r\n    [Lichen.typeName]: Lichen,\r\n    [Lily.typeName]: Lily,\r\n    [Geranium.typeName]: Geranium,\r\n    [Fence.typeName]: Fence,\r\n};\r\n\r\nexport const SEED_ORDER = [\r\n    Daisy.typeName,\r\n    Reed.typeName,\r\n    Cactus.typeName,\r\n    Chromatic.typeName,\r\n    Wandering.typeName,\r\n    Mushroom.typeName,\r\n    Lichen.typeName,\r\n    Lily.typeName,\r\n    Geranium.typeName,\r\n    Blight.typeName,\r\n    Fence.typeName,\r\n];\r\n\r\nexport const SEED_COSTS = {\r\n    daisy: 30,\r\n    reed: 40,\r\n    cactus: 50,\r\n    chromatic: 80,\r\n    wanderer: 120,\r\n    blight: 200,\r\n    fence: 1,\r\n    mushroom: 60,\r\n    lichen: 40,\r\n    geranium: 60,\r\n    lily: 80,\r\n};\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours4, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Reed extends Plant {\r\n    static typeName = \"reed\";\r\n    static displayName = \"Reed\";\r\n    static maxStage = 4;\r\n\r\n    static canPlantOn(x, y, state) {\r\n        const baseTile = state.baseGrid[y][x];\r\n        if (baseTile === \"mud\") return true;\r\n        if (baseTile !== \"water\") return false;\r\n        return !Reed._isDeepWaterPocket(x, y, state);\r\n    }\r\n\r\n    static _isDeepWaterPocket(x, y, state) {\r\n        // \"Deep water pocket\" means:\r\n        // tile is water AND all 8 neighbours are water.\r\n        if (state.baseGrid[y][x] !== \"water\") return false;\r\n\r\n        for (const [nx, ny] of neighbours8(x, y)) {\r\n            if (!inBounds(nx, ny)) return false;\r\n            if (state.baseGrid[ny][nx] !== \"water\") return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        const fast = (state.baseGrid[y][x] === \"water\") ? 2 : 3;\r\n        if (st.stage < this.maxStage && st.age % fast === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        if (st.stage < 3) return;\r\n        if (st.age % 5 !== 0) return;\r\n\r\n        const cap = (state.baseGrid[y][x] === \"water\") ? 10 : 7;\r\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\r\n        if (local >= cap) return;\r\n\r\n        const orth = neighbours4(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n        for (let i = orth.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [orth[i], orth[j]] = [orth[j], orth[i]];\r\n        }\r\n\r\n        const fill = local / cap;\r\n        const chance = 0.45 * (1.0 - fill);\r\n        if (state.rng() > chance) return;\r\n\r\n        const waterFirst = orth.slice().sort((a, b) => {\r\n            const ta = state.baseGrid[a[1]][a[0]] === \"water\" ? 0 : 1;\r\n            const tb = state.baseGrid[b[1]][b[0]] === \"water\" ? 0 : 1;\r\n            return ta - tb;\r\n        });\r\n\r\n        for (const [nx, ny] of waterFirst) {\r\n            if (this._trySpreadTo(this.typeName, x, y, nx, ny, this.canPlantOn, state)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const bottom = py + TILE_SIZE - 4;\r\n        const maxH = TILE_SIZE - 8;\r\n        const height = Math.floor(((st.stage + 1) / (this.maxStage + 1)) * maxH) + 6;\r\n        const top = bottom - height;\r\n        const midX = px + Math.floor(TILE_SIZE / 2);\r\n\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeStyle = \"rgb(60,170,90)\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(midX, bottom);\r\n        ctx.lineTo(midX, top);\r\n        ctx.stroke();\r\n\r\n        ctx.strokeStyle = \"rgb(80,220,120)\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(midX, top + 6);\r\n        ctx.lineTo(midX + 6, top + 2);\r\n        ctx.moveTo(midX, top + 10);\r\n        ctx.lineTo(midX - 6, top + 6);\r\n        ctx.stroke();\r\n    }\r\n}\r\n","import { inBounds, neighbours8 } from \"../helpers.js\";\r\n\r\nexport class Plant {\r\n    static typeName = \"plant\";\r\n    static displayName = \"Plant\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(_x, _y, _state) {\r\n        return this.displayName;\r\n    }\r\n\r\n    static canPlantOn(_x, _y, _state) {\r\n        return false;\r\n    }\r\n\r\n    static init(_x, _y, _state) {\r\n        return {};\r\n    }\r\n\r\n    static plant(x, y, state) {\r\n        state.plantGrid[y][x] = {\r\n            plantType: this.typeName,\r\n            stage: 0,\r\n            age: 0,\r\n            data: this.init(x, y, state),\r\n        };\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n        if (st.stage < this.maxStage && st.age % 3 === 0) {\r\n            st.stage += 1;\r\n        }\r\n    }\r\n\r\n    static draw(_ctx, _px, _py, _state) {\r\n        ctx.strokeStyle = \"rgba(0,0,0,0.9)\";\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);\r\n    }\r\n\r\n    static _countPlantsInRadius(plantType, cx, cy, r, state) {\r\n        let n = 0;\r\n        for (let y = cy - r; y <= cy + r; y++) {\r\n            for (let x = cx - r; x <= cx + r; x++) {\r\n                if (!inBounds(x, y)) continue;\r\n                const st = state.plantGrid[y][x];\r\n                if (st && st.plantType === plantType) n++;\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    static _countPlantsInMoore(plantType, cx, cy, state) {\r\n        let n = 0;\r\n        for (let dy = -1; dy <= 1; dy++) {\r\n            for (let dx = -1; dx <= 1; dx++) {\r\n                if (dx === 0 && dy === 0) continue;\r\n                const x = cx + dx;\r\n                const y = cy + dy;\r\n                if (!inBounds(x, y)) continue;\r\n                const st = state.plantGrid[y][x];\r\n                if (st && st.plantType === plantType) n++;\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    static _isCrowdedForSpreading(x, y, state) {\r\n        // If 6+ of the 8 surrounding tiles contain any plant, treat as too crowded.\r\n        let occupied = 0;\r\n\r\n        for (const [nx, ny] of neighbours8(x, y)) {\r\n            if (!inBounds(nx, ny)) continue;\r\n            if (state.plantGrid[ny][nx]) occupied++;\r\n        }\r\n\r\n        return occupied >= 5;\r\n    }\r\n\r\n\r\n    static _trySpreadTo(plantType, _fromX, _fromY, toX, toY, canPlantOnFn, state) {\r\n        if (!inBounds(toX, toY)) return false;\r\n        if (state.plantGrid[toY][toX]) return false;\r\n        if (!canPlantOnFn(toX, toY, state)) return false;\r\n        if (this._isCrowdedForSpreading(toX, toY, state)) return false;\r\n\r\n        this.plant(toX, toY, state);\r\n        return true;\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Daisy extends Plant {\r\n    static typeName = \"daisy\";\r\n    static displayName = \"Daisy\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return this.displayName + \" (\" + st.data.color + \")\";\r\n    }\r\n\r\n    static init(_x, _y, _state) {\r\n        return { color: \"white\" };\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        const baseTile = state.baseGrid[y][x];\r\n        return baseTile === \"grass\" || baseTile === \"mud\";\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        if (st.stage < this.maxStage && st.age % 3 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        if (st.stage < this.maxStage) return;\r\n        if (st.age % 6 !== 0) return;\r\n\r\n        const local = this._countPlantsInMoore(this.typeName, x, y, state);\r\n        if (local >= 3) return;\r\n\r\n        const candidates = neighbours8(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n        for (let i = candidates.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];\r\n        }\r\n\r\n        candidates.sort((a, b) => {\r\n            const ca = this._countPlantsInMoore(this.typeName, a[0], a[1], state);\r\n            const cb = this._countPlantsInMoore(this.typeName, b[0], b[1], state);\r\n            return ca - cb;\r\n        });\r\n\r\n        if (state.rng() > 0.55) return;\r\n\r\n        // Small chance the new daisy mutates to a different colour.\r\n        const mutationChance = 0.08;\r\n\r\n        const colours = [\"white\", \"yellow\", \"pink\", \"lavender\"];\r\n        const parentColour = st.data?.color ?? \"white\";\r\n\r\n        let childColour = parentColour;\r\n        if (state.rng() < mutationChance) {\r\n            const options = colours.filter((c) => c !== parentColour);\r\n            childColour = options[Math.floor(state.rng() * options.length)];\r\n        }\r\n\r\n        for (const [nx, ny] of candidates) {\r\n            if (this._countPlantsInMoore(this.typeName, nx, ny, state) >= 2) continue;\r\n\r\n            if (this._trySpreadTo(this.typeName, x, y, nx, ny, this.canPlantOn, state)) {\r\n                // Apply inherited/mutated colour to the newly planted daisy.\r\n                const child = state.plantGrid[ny][nx];\r\n                if (child) {\r\n                    child.data = { ...(child.data || {}), color: childColour };\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeStyle = \"rgb(70,180,90)\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(cx, py + TILE_SIZE - 4);\r\n        ctx.lineTo(cx, cy);\r\n        ctx.stroke();\r\n\r\n        const petalR = 2 + st.stage;\r\n        const centreR = 2 + Math.max(0, st.stage - 1);\r\n\r\n        const colourByName = {\r\n            white: \"rgb(240,240,240)\",\r\n            yellow: \"rgb(246, 255, 163)\",\r\n            pink: \"rgb(80, 160, 230)\",\r\n            lavender: \"rgb(220, 208, 255)\",\r\n        };\r\n\r\n        const petalColour = colourByName[st.data?.color] ?? colourByName.white;\r\n\r\n        if (st.stage >= 1) {\r\n            ctx.fillStyle = petalColour;\r\n            const pts = [\r\n                [0, -5], [5, 0], [0, 5], [-5, 0],\r\n                [4, -4], [-4, -4], [4, 4], [-4, 4],\r\n            ];\r\n            for (const [dx, dy] of pts) {\r\n                ctx.beginPath();\r\n                ctx.arc(cx + dx, cy + dy, petalR, 0, Math.PI * 2);\r\n                ctx.fill();\r\n            }\r\n        }\r\n\r\n        ctx.fillStyle = \"rgb(240,210,60)\";\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, Math.max(2, centreR), 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, roundRect } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Cactus extends Plant {\r\n    static typeName = \"cactus\";\r\n    static displayName = \"Cactus\";\r\n    static maxStage = 4;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return this.displayName + \" (\" + st.data.colour + \" flower)\";\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        const baseTile = state.baseGrid[y][x];\r\n        return baseTile === \"sand\";\r\n    }\r\n\r\n    static init(_x, _y, state) {\r\n        const colours = [\"red\", \"yellow\", \"blue\", \"green\", \"cyan\", \"magenta\"];\r\n        return {\r\n            colour: colours[Math.floor(state.rng() * colours.length)],\r\n            flowering: false,\r\n            bloomAge: 0,\r\n        };\r\n    }\r\n\r\n    static _colourToRGB(name) {\r\n        const map = {\r\n            red: \"rgb(255, 70, 70)\",\r\n            yellow: \"rgb(255, 235, 90)\",\r\n            blue: \"rgb(80, 140, 255)\",\r\n            green: \"rgb(90, 255, 130)\",\r\n            cyan: \"rgb(90, 245, 255)\",\r\n            magenta: \"rgb(255, 90, 235)\",\r\n        };\r\n        return map[name] || \"rgb(255, 255, 255)\";\r\n    }\r\n\r\n    static _pickSpreadTarget(x, y, state) {\r\n        const candidates = [];\r\n\r\n        for (let dy = -2; dy <= 2; dy++) {\r\n            for (let dx = -2; dx <= 2; dx++) {\r\n                if (dx === 0 && dy === 0) continue;\r\n\r\n                const nx = x + dx;\r\n                const ny = y + dy;\r\n\r\n                if (!inBounds(nx, ny)) continue;\r\n                if (state.plantGrid[ny][nx]) continue;\r\n                if (!this.canPlantOn(nx, ny, state)) continue;\r\n\r\n                const nearCactus = this._countPlantsInRadius(this.typeName, nx, ny, 1, state);\r\n\r\n                if (nearCactus >= 3) continue;\r\n\r\n                const weight = (nearCactus === 0) ? 6 : (nearCactus === 1 ? 3 : 1);\r\n                candidates.push({ nx, ny, weight });\r\n            }\r\n        }\r\n\r\n        if (candidates.length === 0) return null;\r\n\r\n        let total = 0;\r\n        for (const c of candidates) total += c.weight;\r\n\r\n        let roll = state.rng() * total;\r\n        for (const c of candidates) {\r\n            roll -= c.weight;\r\n            if (roll <= 0) return [c.nx, c.ny];\r\n        }\r\n\r\n        return [candidates[0].nx, candidates[0].ny];\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        // Slow-ish growth, but not too slow.\r\n        if (st.stage < this.maxStage && st.age % 4 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        // Only mature cacti can flower/spread.\r\n        if (st.stage < 2) return;\r\n\r\n        // Flowering is rare, and slightly less likely in dense patches.\r\n        const local2 = this._countPlantsInRadius(this.typeName, x, y, 2, state);\r\n\r\n        if (!st.data.flowering) {\r\n            const crowdPenalty = Math.min(0.12, local2 * 0.02);\r\n            const startChance = 0.06 - crowdPenalty;\r\n\r\n            if (startChance > 0 && state.rng() < startChance) {\r\n                st.data.flowering = true;\r\n                st.data.bloomAge = 0;\r\n            }\r\n        } else {\r\n            st.data.bloomAge += 1;\r\n\r\n            // Flowering doesn't last long.\r\n            const baseStop = 0.12;\r\n            const timeStop = Math.min(0.45, st.data.bloomAge * 0.06);\r\n\r\n            if (state.rng() < (baseStop + timeStop)) {\r\n                st.data.flowering = false;\r\n                st.data.bloomAge = 0;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Spread only while flowering.\r\n        if (!st.data.flowering) return;\r\n\r\n        // Hard cap so deserts don't become solid cactus.\r\n        const local3 = this._countPlantsInRadius(this.typeName, x, y, 3, state);\r\n        if (local3 >= 10) return;\r\n\r\n        // Fast spread attempts while flowering.\r\n        if (state.rng() > 0.75) return;\r\n\r\n        const target = this._pickSpreadTarget(x, y, state);\r\n        if (!target) return;\r\n\r\n        const [nx, ny] = target;\r\n\r\n        this.plant(nx, ny, state);\r\n\r\n        // Inherit hidden colour, with occasional mutation.\r\n        const mutationChance = 0.08;\r\n        const colours = [\"red\", \"yellow\", \"blue\", \"green\", \"cyan\", \"magenta\"];\r\n\r\n        let childColour = st.data.colour;\r\n        if (state.rng() < mutationChance) {\r\n            const options = colours.filter((c) => c !== st.data.colour);\r\n            childColour = options[Math.floor(state.rng() * options.length)];\r\n        }\r\n\r\n        const child = state.plantGrid[ny][nx];\r\n        child.data.colour = childColour;\r\n        child.data.flowering = false;\r\n        child.data.bloomAge = 0;\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const pad = 5;\r\n        const bodyW = TILE_SIZE - pad * 2;\r\n        const maxH = TILE_SIZE - 10;\r\n        const bodyH = Math.floor(((st.stage + 1) / (this.maxStage + 1)) * maxH) + 10;\r\n\r\n        const bx = px + pad;\r\n        const by = py + (TILE_SIZE - bodyH - 4);\r\n\r\n        ctx.fillStyle = \"rgb(60,160,110)\";\r\n        roundRect(ctx, bx, by, bodyW, bodyH, 6);\r\n        ctx.fill();\r\n\r\n        // Spines (small ticks along the body, scaled with height)\r\n        ctx.strokeStyle = \"rgba(255,255,255,0.85)\";\r\n        ctx.lineWidth = 1;\r\n\r\n        const cols = 3;\r\n        for (let c = 0; c < cols; c++) {\r\n            const sx = bx + Math.floor((c + 1) * bodyW / (cols + 1));\r\n\r\n            // Start a little below the top curve, end above the bottom\r\n            const top = by + 6;\r\n            const bottom = by + bodyH - 6;\r\n\r\n            // Space spines based on height\r\n            const step = 6;\r\n            for (let yy = top; yy <= bottom; yy += step) {\r\n                const dir = ((c + Math.floor(yy / step)) % 2 === 0) ? -1 : 1;\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(sx, yy);\r\n                ctx.lineTo(sx + dir * 2, yy + 2);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Flower only while flowering.\r\n        if (st.data.flowering) {\r\n            const cap = this._colourToRGB(st.data.colour);\r\n            const cx = px + TILE_SIZE / 2;\r\n            const topY = by + 4;\r\n\r\n            ctx.fillStyle = cap;\r\n            const petalR = 2;\r\n            const petals = [\r\n                [0, -3], [3, 0], [0, 3], [-3, 0],\r\n                [2, -2], [-2, -2], [2, 2], [-2, 2],\r\n            ];\r\n\r\n            for (const [dx, dy] of petals) {\r\n                ctx.beginPath();\r\n                ctx.arc(cx + dx, topY + dy, petalR, 0, Math.PI * 2);\r\n                ctx.fill();\r\n            }\r\n\r\n            ctx.fillStyle = \"rgb(255, 235, 90)\";\r\n            ctx.beginPath();\r\n            ctx.arc(cx, topY, 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Chromatic extends Plant {\r\n    static typeName = \"chromatic\";\r\n    static displayName = \"Chromatic\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return this.displayName + \" (\" + st.data.base + \")\";\r\n    }\r\n\r\n    static init(_x, _y, state) {\r\n        return { base: state.baseGrid[_y][_x] };\r\n    }\r\n\r\n    static canPlantOn(_x, _y, _state) {\r\n        return true;\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n        if (st.stage < this.maxStage && st.age % 3 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        if (st.stage < this.maxStage) return;\r\n        if (st.age % 7 !== 0) return;\r\n\r\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\r\n        if (local >= 6) return;\r\n\r\n        if (state.rng() > 0.25) return;\r\n\r\n        const candidates = neighbours8(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n        for (let i = candidates.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];\r\n        }\r\n\r\n        for (const [nx, ny] of candidates) {\r\n            if (state.plantGrid[ny][nx]) continue;\r\n            if (this._isCrowdedForSpreading(nx, ny, state)) continue;\r\n            this.plant(nx, ny, state);\r\n            break;\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const colourByTile = {\r\n            mud: \"rgb(160, 110, 80)\",\r\n            grass: \"rgb(80, 200, 110)\",\r\n            water: \"rgb(80, 160, 230)\",\r\n            sand: \"rgb(240, 210, 120)\",\r\n            stone: \"rgb(109, 109, 109)\",\r\n        };\r\n\r\n        const fill = colourByTile[st.data.base] || \"rgb(180, 180, 180)\";\r\n\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        const r = Math.max(3, Math.floor(TILE_SIZE / 7) + st.stage * 2);\r\n\r\n        ctx.fillStyle = fill;\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, r, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        if (st.stage >= 2) {\r\n            ctx.strokeStyle = \"rgba(0,0,0,0.25)\";\r\n            ctx.lineWidth = 2;\r\n            ctx.beginPath();\r\n            ctx.arc(cx, cy, r - 2, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours4 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Wandering extends Plant {\r\n    static typeName = \"wanderer\";\r\n    static displayName = \"Wanderer\";\r\n    static maxStage = 2;\r\n\r\n    static init(_x, _y, _state) {\r\n        return {\r\n            moved: false,\r\n        };\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        const baseTile = state.baseGrid[y][x];\r\n        return baseTile !== \"water\" && baseTile !== \"mud\";\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n        if (st.stage < this.maxStage && st.age % 3 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        if (st.stage < this.maxStage) return;\r\n        if (st.age % 4 !== 0) return;\r\n        if (st.moved) return;\r\n        if (state.rng() > 0.75) return;\r\n\r\n        const adj = neighbours4(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n        const adjWanderers = [];\r\n\r\n        for (const [nx, ny] of adj) {\r\n            const other = state.plantGrid[ny][nx];\r\n            if (other && other.plantType === this.typeName && other.stage === this.maxStage) {\r\n                adjWanderers.push([nx, ny]);\r\n            }\r\n        }\r\n        if (adjWanderers.length === 0) return;\r\n\r\n        const targets = [];\r\n        for (const [nx, ny] of adj) {\r\n            if (state.plantGrid[ny][nx]) continue;\r\n            if (!this.canPlantOn(nx, ny, state)) continue;\r\n            targets.push([nx, ny]);\r\n        }\r\n        if (targets.length === 0) return;\r\n\r\n        const [tx, ty] = targets[Math.floor(state.rng() * targets.length)];\r\n\r\n        state.plantGrid[ty][tx] = {\r\n            plantType: this.typeName,\r\n            stage: 0,\r\n            age: 0,\r\n        };\r\n\r\n        const [dx, dy] = adjWanderers[Math.floor(state.rng() * adjWanderers.length)];\r\n        state.plantGrid[dy][dx] = null;\r\n        st.moved = true;\r\n        state.magic += 1;\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        const r = 4 + st.stage * 2;\r\n\r\n        ctx.fillStyle = \"rgb(170, 110, 210)\";\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, r, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        ctx.fillStyle = \"rgba(0,0,0,0.65)\";\r\n        ctx.beginPath();\r\n        ctx.arc(cx + 2, cy - 1, Math.max(1, r - 4), 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\nimport { PLANT_REGISTRY } from \"./registry.js\";\r\n\r\nexport class Blight extends Plant {\r\n    static typeName = \"blight\";\r\n    static displayName = \"Blight\";\r\n    static maxStage = 1;\r\n\r\n    static canPlantOn(_x, _y, _state) {\r\n        return true;\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n        st.stage = 1;\r\n\r\n        if (st.age % 2 !== 0) return;\r\n\r\n        const candidates = neighbours8(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n        if (candidates.length === 0) return;\r\n\r\n        for (let i = candidates.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];\r\n        }\r\n\r\n        for (const [nx, ny] of candidates) {\r\n            const other = state.plantGrid[ny][nx];\r\n            if (!other) continue;\r\n\r\n            if (other.plantType === this.typeName) continue;\r\n            if (other.plantType === \"fence\") continue;\r\n\r\n            const otherCls = PLANT_REGISTRY[other.plantType];\r\n            if (!otherCls) continue;\r\n            if (other.stage !== otherCls.maxStage) continue;\r\n\r\n            state.plantGrid[ny][nx] = {\r\n                plantType: this.typeName,\r\n                stage: 1,\r\n                age: 0,\r\n            };\r\n            break;\r\n        }\r\n\r\n        if (state.rng() > 0.9) {\r\n            state.plantGrid[y][x] = null;\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, _st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        ctx.fillStyle = \"rgb(10, 40, 90)\";\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, Math.floor(TILE_SIZE / 3), 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        ctx.strokeStyle = \"rgb(150, 80, 80)\";\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, Math.floor(TILE_SIZE / 3) - 2, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Mushroom extends Plant {\r\n    static typeName = \"mushroom\";\r\n    static displayName = \"Mushroom\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return `${this.displayName} (${st.data.cap} cap)`;\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        const baseTile = state.baseGrid[y][x];\r\n        return baseTile === \"grass\" || baseTile === \"mud\";\r\n    }\r\n\r\n    static init(_x, _y, _state) {\r\n        // Always plants brown.\r\n        return { cap: \"brown\" };\r\n    }\r\n\r\n    static _pickCapWeighted(state) {\r\n        const weighted = [\r\n            [\"brown\", 40],\r\n            [\"tan\", 18],\r\n            [\"cream\", 14],\r\n            [\"red\", 10],\r\n            [\"orange\", 8],\r\n            [\"yellow\", 7],\r\n            [\"purple\", 5],\r\n            [\"blue\", 3],\r\n            [\"black\", 2],\r\n            [\"white\", 2],\r\n            [\"glow\", 1],\r\n        ];\r\n\r\n        let total = 0;\r\n        for (const [, w] of weighted) total += w;\r\n\r\n        let r = state.rng() * total;\r\n        for (const [name, w] of weighted) {\r\n            r -= w;\r\n            if (r <= 0) return name;\r\n        }\r\n\r\n        return \"brown\";\r\n    }\r\n\r\n    static _countHostileAdjacency(tx, ty, state) {\r\n        // Count adjacent plants that are NOT mushroom and NOT fence.\r\n        let n = 0;\r\n        for (const [ax, ay] of neighbours8(tx, ty)) {\r\n            if (!inBounds(ax, ay)) continue;\r\n            const other = state.plantGrid[ay][ax];\r\n            if (!other) continue;\r\n            if (other.plantType === this.typeName) continue;\r\n            if (other.plantType === \"fence\") continue;\r\n            n++;\r\n        }\r\n        return n;\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        // Grow a bit slowly.\r\n        if (st.stage < this.maxStage && st.age % 4 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        // Only burst-spread once mature and \"old enough\"\r\n        if (st.stage < this.maxStage) return;\r\n        if (st.age < 24) return;\r\n        if (st.age % 4 !== 0) return;\r\n\r\n        // Find valid adjacent squares\r\n        const valid = [];\r\n\r\n        for (const [nx, ny] of neighbours8(x, y)) {\r\n            if (!inBounds(nx, ny)) continue;\r\n\r\n            // Can't plant there at all\r\n            if (!this.canPlantOn(nx, ny, state)) continue;\r\n\r\n            // Already occupied by any plant\r\n            if (state.plantGrid[ny][nx]) continue;\r\n\r\n            // Too many hostile neighbours (3+ non-mushroom, non-fence plants)\r\n            const hostile = this._countHostileAdjacency(nx, ny, state);\r\n            if (hostile >= 3) continue;\r\n\r\n            valid.push([nx, ny]);\r\n        }\r\n\r\n        // Only burst if there are enough good places to seed\r\n        if (valid.length < 4) return;\r\n\r\n        // Burst: the mushroom dies...\r\n        state.plantGrid[y][x] = null;\r\n\r\n        // ...and seeds each valid square with a 75% chance\r\n        for (const [sx, sy] of valid) {\r\n            if (state.rng() > 0.45) continue;\r\n\r\n            this.plant(sx, sy, state);\r\n\r\n            const child = state.plantGrid[sy][sx];\r\n            if (child) {\r\n                if (state.rng() > 0.9) {\r\n                    child.data.cap = this._pickCapWeighted(state);\r\n                } else {\r\n                    child.data.cap = st.data.cap;\r\n                }\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const bottom = py + TILE_SIZE;\r\n\r\n        const stemH = st.stage * 3;\r\n        const stemW = 3;\r\n\r\n        const capR = 3 + st.stage * 2;\r\n\r\n        const capByName = {\r\n            brown: \"rgb(140, 90, 60)\",\r\n            tan: \"rgb(190, 150, 105)\",\r\n            cream: \"rgb(220, 210, 190)\",\r\n            red: \"rgb(190, 60, 60)\",\r\n            orange: \"rgb(235, 140, 70)\",\r\n            yellow: \"rgb(245, 225, 90)\",\r\n            purple: \"rgb(150, 110, 190)\",\r\n            blue: \"rgb(90, 140, 255)\",\r\n            black: \"rgb(35, 35, 35)\",\r\n            white: \"rgb(245, 245, 245)\",\r\n            glow: \"rgb(120, 255, 210)\",\r\n        };\r\n\r\n        const capFill = capByName[st.data.cap] ?? capByName.brown;\r\n\r\n        // Stem\r\n        ctx.fillStyle = \"rgb(220, 210, 190)\";\r\n        ctx.fillRect(cx - Math.floor(stemW / 2), bottom - stemH, stemW, stemH);\r\n\r\n        // Cap\r\n        ctx.fillStyle = capFill;\r\n        ctx.beginPath();\r\n        ctx.arc(cx, bottom - stemH, capR, Math.PI, 0);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Spots when mature\r\n        if (st.stage >= 2) {\r\n            ctx.fillStyle = \"rgba(255,255,255,0.75)\";\r\n            const spots = [\r\n                [-2, -1],\r\n                [2, -2],\r\n                [0, -3],\r\n            ];\r\n            for (const [dx, dy] of spots) {\r\n                ctx.beginPath();\r\n                ctx.arc(cx + dx, bottom - stemH + dy, 1, 0, Math.PI * 2);\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Lichen extends Plant {\r\n    static typeName = \"lichen\";\r\n    static displayName = \"Lichen\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return this.displayName + \" (\" + st.data.hue + \")\";\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        return state.baseGrid[y][x] === \"stone\";\r\n    }\r\n\r\n    static init(_x, _y, state) {\r\n        const hues = [\"mint\", \"teal\", \"gold\", \"rust\"];\r\n        return {\r\n            hue: hues[Math.floor(state.rng() * hues.length)],\r\n        };\r\n    }\r\n\r\n    static _hueToColour(hue) {\r\n        const map = {\r\n            mint: \"rgb(150, 230, 170)\",\r\n            teal: \"rgb(90, 210, 200)\",\r\n            gold: \"rgb(235, 210, 120)\",\r\n            rust: \"rgb(210, 140, 90)\",\r\n        };\r\n        return map[hue] || \"rgb(200, 200, 200)\";\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        // Very slow growth\r\n        if (st.stage < this.maxStage && st.age % 6 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        // Only mature lichen spreads\r\n        if (st.stage < this.maxStage) return;\r\n\r\n        // Spread is infrequent\r\n        if (st.age % 7 !== 0) return;\r\n\r\n        // Self-limit: don't spread if already dense nearby\r\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\r\n        if (local >= 7) return;\r\n\r\n        // Chance to spread (small)\r\n        if (state.rng() > 0.28) return;\r\n\r\n        // Prefer targets with 1-2 nearby lichen (patch edge), avoid packed centres\r\n        const candidates = neighbours8(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n\r\n        // Shuffle\r\n        for (let i = candidates.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];\r\n        }\r\n\r\n        candidates.sort((a, b) => {\r\n            const ca = this._countPlantsInMoore(this.typeName, a[0], a[1], state);\r\n            const cb = this._countPlantsInMoore(this.typeName, b[0], b[1], state);\r\n            return ca - cb;\r\n        });\r\n\r\n        for (const [nx, ny] of candidates) {\r\n            if (state.plantGrid[ny][nx]) continue;\r\n            if (!this.canPlantOn(nx, ny, state)) continue;\r\n\r\n            // Avoid landing in very crowded spots\r\n            const near = this._countPlantsInMoore(this.typeName, nx, ny, state);\r\n            if (near >= 4) continue;\r\n\r\n            this.plant(nx, ny, state);\r\n\r\n            // Inherit hue most of the time, with rare mutation\r\n            const mutationChance = 0.08;\r\n            const hues = [\"mint\", \"teal\", \"gold\", \"rust\"];\r\n\r\n            const parentHue = st.data.hue;\r\n            let childHue = parentHue;\r\n\r\n            if (state.rng() < mutationChance) {\r\n                const options = hues.filter((h) => h !== parentHue);\r\n                childHue = options[Math.floor(state.rng() * options.length)];\r\n            }\r\n\r\n            const child = state.plantGrid[ny][nx];\r\n            child.data.hue = childHue;\r\n\r\n            break;\r\n        }\r\n\r\n        // Optional: very rare \"weathering\" effect\r\n        // Lichen slowly breaks stone into sand, but only when fully mature.\r\n        // Comment this out if you don't want plants to affect terrain.\r\n        if (state.rng() < 0.01) {\r\n            state.baseGrid[y][x] = \"sand\";\r\n            state.plantGrid[y][x] = null;\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        // Patch size grows with stage\r\n        const r = 3 + st.stage * 2;\r\n\r\n        ctx.fillStyle = this._hueToColour(st.data.hue);\r\n\r\n        // Blobby lichen patch (several circles)\r\n        const blobs = [\r\n            [0, 0],\r\n            [-3, 1],\r\n            [3, -1],\r\n            [1, 3],\r\n            [-1, -3],\r\n        ];\r\n\r\n        for (const [dx, dy] of blobs) {\r\n            ctx.beginPath();\r\n            ctx.arc(cx + dx, cy + dy, r / 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        // Outline hint so it reads on stone\r\n        ctx.strokeStyle = \"rgba(0,0,0,0.25)\";\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, r / 2, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Lily extends Plant {\r\n    static typeName = \"lily\";\r\n    static displayName = \"Lily\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return this.displayName + \" (\" + st.data.colour + \" flower)\";\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        if (state.baseGrid[y][x] !== \"water\") return false;\r\n\r\n        let waterCount = 0;\r\n        for (const [nx, ny] of neighbours8(x, y)) {\r\n            if (!inBounds(nx, ny)) continue;\r\n            if (state.baseGrid[ny][nx] === \"water\") waterCount++;\r\n        }\r\n\r\n        return waterCount >= 6;\r\n    }\r\n\r\n    static init(_x, _y, state) {\r\n        const colours = [\"red\", \"yellow\", \"blue\", \"green\", \"cyan\", \"magenta\"];\r\n        return {\r\n            colour: colours[Math.floor(state.rng() * colours.length)],\r\n            flowering: false,\r\n            bloomAge: 0,\r\n            notchAngle: state.rng() * Math.PI * 2,\r\n        };\r\n    }\r\n\r\n    static _colourToRGB(name) {\r\n        const map = {\r\n            red: \"rgb(255, 70, 70)\",\r\n            yellow: \"rgb(255, 235, 90)\",\r\n            blue: \"rgb(80, 140, 255)\",\r\n            green: \"rgb(90, 255, 130)\",\r\n            cyan: \"rgb(90, 245, 255)\",\r\n            magenta: \"rgb(255, 90, 235)\",\r\n        };\r\n        return map[name] || \"rgb(255, 255, 255)\";\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        // Grow slowly\r\n        if (st.stage < this.maxStage && st.age % 5 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        // Only mature lilies can flower/spread\r\n        if (st.stage < 2) return;\r\n\r\n        // --- Flowering state machine (cactus-like) ---\r\n        if (!st.data.flowering) {\r\n            // Rare start\r\n            if (state.rng() < 0.05) {\r\n                st.data.flowering = true;\r\n                st.data.bloomAge = 0;\r\n            }\r\n        } else {\r\n            st.data.bloomAge += 1;\r\n\r\n            // Flowering doesn't last long\r\n            const baseStop = 0.10;\r\n            const timeStop = Math.min(0.50, st.data.bloomAge * 0.06);\r\n\r\n            if (state.rng() < (baseStop + timeStop)) {\r\n                st.data.flowering = false;\r\n                st.data.bloomAge = 0;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Optional: spread only while flowering, but very gently\r\n        if (!st.data.flowering) return;\r\n        if (st.age % 3 !== 0) return;\r\n\r\n        // Self-limit: don't overcrowd deep water\r\n        const local = this._countPlantsInRadius(this.typeName, x, y, 2, state);\r\n        if (local >= 8) return;\r\n\r\n        if (state.rng() > 0.35) return;\r\n\r\n        const candidates = neighbours8(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n\r\n        // Shuffle\r\n        for (let i = candidates.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];\r\n        }\r\n\r\n        for (const [nx, ny] of candidates) {\r\n            if (state.plantGrid[ny][nx]) continue;\r\n            if (!this.canPlantOn(nx, ny, state)) continue;\r\n\r\n            this.plant(nx, ny, state);\r\n\r\n            // Inherit flower colour, rare mutation\r\n            const mutationChance = 0.06;\r\n            const colours = [\"red\", \"yellow\", \"blue\", \"green\", \"cyan\", \"magenta\"];\r\n\r\n            let childColour = st.data.colour;\r\n            if (state.rng() < mutationChance) {\r\n                const options = colours.filter((c) => c !== st.data.colour);\r\n                childColour = options[Math.floor(state.rng() * options.length)];\r\n            }\r\n\r\n            const child = state.plantGrid[ny][nx];\r\n            child.data.colour = childColour;\r\n            child.data.flowering = false;\r\n            child.data.bloomAge = 0;\r\n\r\n            break;\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        // Pad (leaf)\r\n        ctx.fillStyle = \"rgb(70, 170, 120)\";\r\n        ctx.beginPath();\r\n        ctx.ellipse(cx, cy + 2, 7, 5, 0, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Notch cut (random direction)\r\n        const a = st.data.notchAngle;\r\n\r\n        ctx.fillStyle = \"rgba(0,0,0,0.25)\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(cx, cy + 2);\r\n        ctx.arc(cx, cy + 2, 7, a - 0.35, a + 0.35);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n\r\n        // Flower only while flowering\r\n        if (st.data.flowering) {\r\n            const col = this._colourToRGB(st.data.colour);\r\n\r\n            ctx.fillStyle = col;\r\n\r\n            const petalR = 2;\r\n            const petals = [\r\n                [0, -5], [5, 0], [0, 5], [-5, 0],\r\n                [3, -3], [-3, -3], [3, 3], [-3, 3],\r\n            ];\r\n\r\n            for (const [dx, dy] of petals) {\r\n                ctx.beginPath();\r\n                ctx.arc(cx + dx, cy - 3 + dy, petalR, 0, Math.PI * 2);\r\n                ctx.fill();\r\n            }\r\n\r\n            ctx.fillStyle = \"rgb(255, 235, 90)\";\r\n            ctx.beginPath();\r\n            ctx.arc(cx, cy - 3, 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { inBounds, neighbours8 } from \"../helpers.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Geranium extends Plant {\r\n    static typeName = \"geranium\";\r\n    static displayName = \"Geranium\";\r\n    static maxStage = 3;\r\n\r\n    static getDescription(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        return this.displayName + \" (\" + st.data.colour + \")\";\r\n    }\r\n\r\n    static canPlantOn(x, y, state) {\r\n        const base = state.baseGrid[y][x];\r\n        return base === \"grass\" || base === \"mud\";\r\n    }\r\n\r\n    static init(_x, _y, _state) {\r\n        // Always start white when manually planted.\r\n        return { colour: \"white\" };\r\n    }\r\n\r\n    static _pickColourWeighted(state) {\r\n        // Weighted palette: common colours show up a lot, rare ones occasionally.\r\n        // Weights are relative, not percentages.\r\n        const weighted = [\r\n            [\"white\", 40],\r\n            [\"red\", 18],\r\n            [\"pink\", 18],\r\n            [\"salmon\", 12],\r\n            [\"magenta\", 10],\r\n            [\"purple\", 10],\r\n            [\"lavender\", 10],\r\n            [\"orange\", 8],\r\n            [\"yellow\", 8],\r\n            [\"peach\", 7],\r\n            [\"deepblue\", 7],\r\n            [\"crimson\", 6],\r\n            [\"scarlet\", 6],\r\n            [\"hotpink\", 5],\r\n            [\"violet\", 5],\r\n            [\"blue\", 3],       // rare-ish\r\n            [\"teal\", 2],       // rare\r\n            [\"black\", 1],      // very rare\r\n            [\"gold\", 1],       // very rare\r\n        ];\r\n\r\n        let total = 0;\r\n        for (const [, w] of weighted) total += w;\r\n\r\n        let r = state.rng() * total;\r\n        for (const [name, w] of weighted) {\r\n            r -= w;\r\n            if (r <= 0) return name;\r\n        }\r\n\r\n        return \"white\";\r\n    }\r\n\r\n    static _colourToRGB(name) {\r\n        const map = {\r\n            white: \"rgb(245,245,245)\",\r\n            red: \"rgb(230,70,70)\",\r\n            pink: \"rgb(240,120,170)\",\r\n            salmon: \"rgb(240,140,120)\",\r\n            magenta: \"rgb(230,90,220)\",\r\n            purple: \"rgb(160,90,230)\",\r\n            lavender: \"rgb(210,180,255)\",\r\n            orange: \"rgb(245,150,70)\",\r\n            yellow: \"rgb(250,235,90)\",\r\n            peach: \"rgb(255,190,150)\",\r\n            deepblue: \"rgb(55, 29, 250)\",\r\n            crimson: \"rgb(190,40,70)\",\r\n            scarlet: \"rgb(252, 26, 26)\",\r\n            hotpink: \"rgb(255,80,200)\",\r\n            violet: \"rgb(170,110,255)\",\r\n            blue: \"rgb(90,140,255)\",\r\n            teal: \"rgb(90,220,210)\",\r\n            black: \"rgb(30,30,30)\",\r\n            gold: \"rgb(251, 203, 61)\",\r\n        };\r\n\r\n        return map[name] || \"rgb(245,245,245)\";\r\n    }\r\n\r\n    static onTick(x, y, state) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) return;\r\n\r\n        st.age += 1;\r\n\r\n        if (st.stage < this.maxStage && st.age % 3 === 0) {\r\n            st.stage += 1;\r\n        }\r\n\r\n        // Only spread when mature\r\n        if (st.stage < this.maxStage) return;\r\n        if (st.age % 6 !== 0) return;\r\n\r\n        // Local crowd limit\r\n        const local = this._countPlantsInMoore(this.typeName, x, y, state);\r\n        if (local >= 3) return;\r\n\r\n        const candidates = neighbours8(x, y).filter(([nx, ny]) => inBounds(nx, ny));\r\n\r\n        // Shuffle\r\n        for (let i = candidates.length - 1; i > 0; i--) {\r\n            const j = Math.floor(state.rng() * (i + 1));\r\n            [candidates[i], candidates[j]] = [candidates[j], candidates[i]];\r\n        }\r\n\r\n        // Prefer less crowded targets\r\n        candidates.sort((a, b) => {\r\n            const ca = this._countPlantsInMoore(this.typeName, a[0], a[1], state);\r\n            const cb = this._countPlantsInMoore(this.typeName, b[0], b[1], state);\r\n            return ca - cb;\r\n        });\r\n\r\n        if (state.rng() > 0.55) return;\r\n\r\n        const parentColour = st.data.colour;\r\n\r\n        // Mutation:\r\n        // - Most of the time inherit\r\n        // - Sometimes pick a new colour (with rare colours possible)\r\n        // - White is a bit \"unstable\" so it mutates slightly more often\r\n        const mutationChance = (parentColour === \"white\") ? 0.14 : 0.08;\r\n\r\n        let childColour = parentColour;\r\n        if (state.rng() < mutationChance) {\r\n            childColour = this._pickColourWeighted(state);\r\n        }\r\n\r\n        for (const [nx, ny] of candidates) {\r\n            if (this._countPlantsInMoore(this.typeName, nx, ny, state) >= 2) continue;\r\n\r\n            if (this._trySpreadTo(this.typeName, x, y, nx, ny, this.canPlantOn, state)) {\r\n                const child = state.plantGrid[ny][nx];\r\n                child.data.colour = childColour;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    static draw(ctx, px, py, st) {\r\n        const cx = px + TILE_SIZE / 2;\r\n        const cy = py + TILE_SIZE / 2;\r\n\r\n        // Stem (shorter, thicker than daisy)\r\n        ctx.lineWidth = 2;\r\n        ctx.strokeStyle = \"rgb(60,170,90)\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(cx, py + TILE_SIZE - 5);\r\n        ctx.lineTo(cx, cy + 2);\r\n        ctx.stroke();\r\n\r\n        // Leaves near base (geranium-ish)\r\n        ctx.fillStyle = \"rgb(70,190,110)\";\r\n        ctx.beginPath();\r\n        ctx.ellipse(cx - 4, py + TILE_SIZE - 6, 4, 2, -0.3, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        ctx.beginPath();\r\n        ctx.ellipse(cx + 4, py + TILE_SIZE - 6, 4, 2, 0.3, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        if (st.stage < 1) return;\r\n\r\n        // Flower head: dense cluster of bigger petals\r\n        const bloomR = 3 + st.stage; // overall size\r\n        const petalR = 2 + Math.floor(st.stage / 2);\r\n\r\n        const flowerCol = this._colourToRGB(st.data.colour);\r\n\r\n        // Outer petals (6 petals, rounder look)\r\n        ctx.fillStyle = flowerCol;\r\n\r\n        const pts = [\r\n            [0, -5], [4, -3], [5, 0], [4, 3], [0, 5], [-4, 3], [-5, 0], [-4, -3],\r\n        ];\r\n\r\n        for (const [dx, dy] of pts) {\r\n            ctx.beginPath();\r\n            ctx.arc(cx + dx, cy + dy, petalR, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        // Inner fill to make it look like a single \"ball\" bloom\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, bloomR, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Darker centre (geraniums often have a visible core)\r\n        ctx.fillStyle = \"rgba(0,0,0,0.25)\";\r\n        ctx.beginPath();\r\n        ctx.arc(cx, cy, Math.max(2, bloomR - 2), 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Small highlight dot\r\n        ctx.fillStyle = \"rgba(255,255,255,0.35)\";\r\n        ctx.beginPath();\r\n        ctx.arc(cx - 1, cy - 1, 1, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n}\r\n","import { TILE_SIZE } from \"../config.js\";\r\nimport { Plant } from \"./Plant.js\";\r\n\r\nexport class Fence extends Plant {\r\n    static typeName = \"fence\";\r\n    static displayName = \"Fence\";\r\n    static maxStage = 0;\r\n\r\n    static canPlantOn(_x, _y, _state) {\r\n        return true;\r\n    }\r\n\r\n    static onTick(_x, _y, _state) {}\r\n\r\n    static draw(ctx, px, py, _st) {\r\n        const x0 = px;\r\n        const y0 = py;\r\n\r\n        const inset = 3;\r\n        const top = y0 + 5;\r\n        const bottom = y0 + TILE_SIZE - 4;\r\n\r\n        const leftX = x0 + inset + 2;\r\n        const rightX = x0 + TILE_SIZE - inset - 2;\r\n\r\n        const rail1Y = y0 + 9;\r\n        const rail2Y = y0 + 14;\r\n\r\n        ctx.fillStyle = \"rgb(170,140,95)\";\r\n        ctx.strokeStyle = \"rgba(0,0,0,0.9)\";\r\n        ctx.lineWidth = 1;\r\n\r\n        ctx.fillRect(leftX - 1, top, 3, bottom - top);\r\n        ctx.fillRect(rightX - 1, top, 3, bottom - top);\r\n\r\n        ctx.fillRect(leftX + 2, rail1Y, (rightX - leftX) - 3, 3);\r\n        ctx.fillRect(leftX + 2, rail2Y, (rightX - leftX) - 3, 3);\r\n\r\n        ctx.fillRect(leftX - 2, top - 2, 5, 3);\r\n        ctx.fillRect(rightX - 2, top - 2, 5, 3);\r\n    }\r\n}\r\n","import { GRID_W, GRID_H, SAVE_KEY, TILES } from \"./config.js\";\r\nimport { clamp } from \"./helpers.js\";\r\nimport { PLANT_REGISTRY } from \"./plants/registry.js\";\r\n\r\nexport function saveState(state) {\r\n    const data = {\r\n        w: GRID_W,\r\n        h: GRID_H,\r\n        base: state.baseGrid,\r\n        plants: state.plantGrid,\r\n        magic: state.magic,\r\n    };\r\n    localStorage.setItem(SAVE_KEY, JSON.stringify(data));\r\n}\r\n\r\nexport function loadState(state) {\r\n    const raw = localStorage.getItem(SAVE_KEY);\r\n    if (!raw) return;\r\n\r\n    try {\r\n        const data = JSON.parse(raw);\r\n\r\n        if (Array.isArray(data.base) && data.base.length === GRID_H) {\r\n            for (let y = 0; y < GRID_H; y++) {\r\n                const row = data.base[y];\r\n                if (!Array.isArray(row) || row.length !== GRID_W) continue;\r\n\r\n                for (let x = 0; x < GRID_W; x++) {\r\n                    const v = row[x];\r\n                    state.baseGrid[y][x] = TILES.includes(v) ? v : \"grass\";\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Array.isArray(data.plants) && data.plants.length === GRID_H) {\r\n            for (let y = 0; y < GRID_H; y++) {\r\n                const row = data.plants[y];\r\n                if (!Array.isArray(row) || row.length !== GRID_W) continue;\r\n\r\n                for (let x = 0; x < GRID_W; x++) {\r\n                    const cell = row[x];\r\n\r\n                    if (cell === null) {\r\n                        state.plantGrid[y][x] = null;\r\n                        continue;\r\n                    }\r\n\r\n                    if (!cell || typeof cell !== \"object\") {\r\n                        state.plantGrid[y][x] = null;\r\n                        continue;\r\n                    }\r\n\r\n                    const pt = cell.plantType;\r\n                    if (!pt || !PLANT_REGISTRY[pt]) {\r\n                        state.plantGrid[y][x] = null;\r\n                        continue;\r\n                    }\r\n\r\n                    state.plantGrid[y][x] = {\r\n                        plantType: pt,\r\n                        stage: clamp(cell.stage | 0, 0, 99),\r\n                        age: clamp(cell.age | 0, 0, 999999),\r\n                        data: cell.data,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        if (typeof data.magic === \"number\") {\r\n            state.magic = Math.max(0, Math.floor(data.magic));\r\n        }\r\n    } catch (e) {\r\n        // ignore\r\n    }\r\n}\r\n","import { TILE_SIZE, TILES, TILE_COLOURS } from \"./config.js\";\r\nimport { inBounds } from \"./helpers.js\";\r\nimport { PLANT_REGISTRY, SEED_ORDER, SEED_COSTS } from \"./plants/registry.js\";\r\nimport { clearAll } from \"./state.js\";\r\nimport { generateNaturalBaseGrid } from \"./terrain.js\";\r\nimport { INIT_MAGIC } from \"./config.js\";\r\n\r\nexport function updateMagicCount(count) {\r\n    const magicCount = document.getElementById(\"magicCount\");\r\n    magicCount.textContent = String(count);\r\n}\r\n\r\nexport function setupUI(state, canvas) {\r\n    const tileButtons = document.getElementById(\"tileButtons\");\r\n    const seedButtons = document.getElementById(\"seedButtons\");\r\n    const tickPill = document.getElementById(\"tickPill\");\r\n    const gridPill = document.getElementById(\"gridPill\");\r\n    const magicCount = document.getElementById(\"magicCount\");\r\n    const inspector = document.getElementById(\"inspector\");\r\n\r\n    function makeButton(label, kind, value, swatchColour, cost) {\r\n        const b = document.createElement(\"div\");\r\n        b.className = \"btn\";\r\n        b.dataset.kind = kind;\r\n        b.dataset.value = value;\r\n\r\n        if (swatchColour) {\r\n            const s = document.createElement(\"div\");\r\n            s.className = \"swatch\";\r\n            s.style.background = swatchColour;\r\n            b.appendChild(s);\r\n        }\r\n\r\n        const t = document.createElement(\"div\");\r\n        t.textContent = label;\r\n        b.appendChild(t);\r\n\r\n        if (typeof cost === \"number\") {\r\n            const c = document.createElement(\"div\");\r\n            c.className = \"cost\";\r\n            c.textContent = `${cost}`;\r\n            b.appendChild(c);\r\n        }\r\n\r\n        b.addEventListener(\"click\", () => {\r\n            state.selectedTool = kind;\r\n            state.selectedValue = value;\r\n            refreshButtons();\r\n        });\r\n\r\n        return b;\r\n    }\r\n\r\n    const tileBtnEls = [];\r\n    for (const t of TILES) {\r\n        const el = makeButton(t, \"tile\", t, TILE_COLOURS[t], 1);\r\n        tileButtons.appendChild(el);\r\n        tileBtnEls.push(el);\r\n    }\r\n\r\n    const seedBtnEls = [];\r\n    for (const s of SEED_ORDER) {\r\n        const cls = PLANT_REGISTRY[s];\r\n        const cost = SEED_COSTS[s] ?? 1;\r\n        const el = makeButton(cls.displayName, \"seed\", s, null, cost);\r\n        seedButtons.appendChild(el);\r\n        seedBtnEls.push(el);\r\n    }\r\n\r\n    function refreshButtons() {\r\n        for (const el of tileBtnEls) {\r\n            const isSel = state.selectedTool === \"tile\" && state.selectedValue === el.dataset.value;\r\n            el.classList.toggle(\"selected\", isSel);\r\n        }\r\n        for (const el of seedBtnEls) {\r\n            const isSel = state.selectedTool === \"seed\" && state.selectedValue === el.dataset.value;\r\n            el.classList.toggle(\"selected\", isSel);\r\n        }\r\n\r\n        tickPill.textContent = `Tick: ${state.paused ? \"paused\" : \"running\"}`;\r\n        gridPill.textContent = `Grid: ${state.showGrid ? \"on\" : \"off\"}`;\r\n        magicCount.textContent = String(state.magic);\r\n    }\r\n\r\n    refreshButtons();\r\n\r\n    canvas.addEventListener(\"contextmenu\", (e) => e.preventDefault());\r\n\r\n    function getGridPosFromEvent(e) {\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mx = e.clientX - rect.left;\r\n        const my = e.clientY - rect.top;\r\n        const gx = Math.floor(mx / TILE_SIZE);\r\n        const gy = Math.floor(my / TILE_SIZE);\r\n        if (!inBounds(gx, gy)) return null;\r\n        return [gx, gy];\r\n    }\r\n\r\n    function applyToolAt(gx, gy, button) {\r\n        if (!inBounds(gx, gy)) return;\r\n\r\n        if (button === 2) {\r\n            const st = state.plantGrid[gy][gx];\r\n\r\n            if (st) {\r\n                const cls = PLANT_REGISTRY[st.plantType];\r\n\r\n                // Only reward if the plant is fully grown\r\n                if (cls && st.stage === cls.maxStage) {\r\n                    state.magic += Math.ceil(SEED_COSTS[st.plantType] / 10);\r\n                }\r\n\r\n                state.plantGrid[gy][gx] = null;\r\n                updateMagicCount(state.magic)\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (button !== 0) return;\r\n\r\n        if (state.selectedTool === \"tile\" && TILES.includes(state.selectedValue)) {\r\n            // Don't charge if you're painting the same tile type\r\n            if (state.baseGrid[gy][gx] !== state.selectedValue) {\r\n                if (state.magic < 1) return;\r\n                state.magic -= 1;\r\n                magicCount.textContent = String(state.magic);\r\n            }\r\n\r\n            state.baseGrid[gy][gx] = state.selectedValue;\r\n\r\n            const st = state.plantGrid[gy][gx];\r\n            if (st) {\r\n                const cls = PLANT_REGISTRY[st.plantType];\r\n                if (cls && !cls.canPlantOn(gx, gy, state)) {\r\n                    state.plantGrid[gy][gx] = null;\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (state.selectedTool === \"seed\" && PLANT_REGISTRY[state.selectedValue]) {\r\n            if (state.plantGrid[gy][gx]) return;\r\n\r\n            const cls = PLANT_REGISTRY[state.selectedValue];\r\n            if (!cls.canPlantOn(gx, gy, state)) return;\r\n\r\n            const cost = SEED_COSTS[state.selectedValue] ?? 1;\r\n            if (state.magic < cost) return;\r\n\r\n            state.magic -= cost;\r\n            magicCount.textContent = String(state.magic);\r\n            cls.plant(gx, gy, state);\r\n        }\r\n    }\r\n\r\n    function setInspector(text) {\r\n        if (!inspector) return;\r\n        inspector.textContent = text || \"\";\r\n    }\r\n\r\n    function describeCell(gx, gy) {\r\n        if (!inBounds(gx, gy)) return \"\";\r\n\r\n        const st = state.plantGrid[gy][gx];\r\n        if (!st) return \"\";\r\n\r\n        const cls = PLANT_REGISTRY[st.plantType];\r\n        if (!cls) return \"\";\r\n\r\n        if (typeof cls.getDescription === \"function\") {\r\n            return cls.getDescription(gx, gy, state);\r\n        }\r\n\r\n        return cls.displayName;\r\n    }\r\n\r\n    let dragging = false;\r\n    let dragButton = 0;\r\n    let lastCellKey = null;\r\n    let lastInspectKey = null;\r\n\r\n    canvas.addEventListener(\"mousemove\", (e) => {\r\n        const gp = getGridPosFromEvent(e);\r\n\r\n        if (!gp) {\r\n            if (lastInspectKey !== null) {\r\n                lastInspectKey = null;\r\n                setInspector(\"\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const [gx, gy] = gp;\r\n        const key = `${gx},${gy}`;\r\n\r\n        if (key === lastInspectKey) return;\r\n        lastInspectKey = key;\r\n\r\n        setInspector(describeCell(gx, gy));\r\n    });\r\n\r\n    canvas.addEventListener(\"mouseleave\", () => {\r\n        lastInspectKey = null;\r\n        setInspector(\"\");\r\n    });\r\n\r\n    canvas.addEventListener(\"mousedown\", (e) => {\r\n        const gp = getGridPosFromEvent(e);\r\n        if (!gp) return;\r\n\r\n        dragging = true;\r\n        dragButton = e.button;\r\n        lastCellKey = null;\r\n\r\n        const [gx, gy] = gp;\r\n        applyToolAt(gx, gy, dragButton);\r\n        lastCellKey = `${gx},${gy}`;\r\n    });\r\n\r\n    window.addEventListener(\"mouseup\", () => {\r\n        dragging = false;\r\n        lastCellKey = null;\r\n    });\r\n\r\n    canvas.addEventListener(\"mousemove\", (e) => {\r\n        if (!dragging) return;\r\n\r\n        const gp = getGridPosFromEvent(e);\r\n        if (!gp) return;\r\n\r\n        const [gx, gy] = gp;\r\n        const key = `${gx},${gy}`;\r\n        if (key === lastCellKey) return;\r\n\r\n        applyToolAt(gx, gy, dragButton);\r\n        lastCellKey = key;\r\n    });\r\n\r\n    window.addEventListener(\"keydown\", (e) => {\r\n        if (e.repeat) return;\r\n\r\n        if (e.key === \"c\" || e.key === \"C\") {\r\n            clearAll(state);\r\n        } else if (e.key === \"r\" || e.key === \"R\") {\r\n            clearAll(state);\r\n            generateNaturalBaseGrid(state.rng, state.baseGrid);\r\n        }  else if (e.key === \"o\" || e.key === \"O\") {\r\n            clearAll(state);\r\n            generateNaturalBaseGrid(state.rng, state.baseGrid);\r\n            state.magic = INIT_MAGIC;\r\n        } else if (e.key === \"g\" || e.key === \"G\") {\r\n            state.showGrid = !state.showGrid;\r\n        } else if (e.key === \" \") {\r\n            state.paused = !state.paused;\r\n        }\r\n\r\n        refreshButtons();\r\n    });\r\n\r\n    return { refreshButtons };\r\n}\r\n","import { GRID_W, GRID_H } from \"./config.js\";\r\nimport { inBounds } from \"./helpers.js\";\r\n\r\nfunction randInt(rng, min, maxInclusive) {\r\n    return min + Math.floor(rng() * (maxInclusive - min + 1));\r\n}\r\n\r\nfunction cloneGrid(grid) {\r\n    const out = [];\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        out.push(grid[y].slice());\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction count8(grid, x, y, tileType) {\r\n    let n = 0;\r\n    for (let dy = -1; dy <= 1; dy++) {\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            if (dx === 0 && dy === 0) continue;\r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n            if (!inBounds(nx, ny)) continue;\r\n            if (grid[ny][nx] === tileType) n++;\r\n        }\r\n    }\r\n    return n;\r\n}\r\n\r\nfunction count4(grid, x, y, tileType) {\r\n    let n = 0;\r\n    const dirs = [\r\n        [1, 0],\r\n        [-1, 0],\r\n        [0, 1],\r\n        [0, -1],\r\n    ];\r\n    for (const [dx, dy] of dirs) {\r\n        const nx = x + dx;\r\n        const ny = y + dy;\r\n        if (!inBounds(nx, ny)) continue;\r\n        if (grid[ny][nx] === tileType) n++;\r\n    }\r\n    return n;\r\n}\r\n\r\nfunction randomWalkCarve(rng, grid, tileType, startX, startY, steps, brushRadius) {\r\n    let x = startX;\r\n    let y = startY;\r\n\r\n    const dirs = [\r\n        [1, 0],\r\n        [-1, 0],\r\n        [0, 1],\r\n        [0, -1],\r\n    ];\r\n\r\n    for (let i = 0; i < steps; i++) {\r\n        // Carve with a brush\r\n        for (let by = -brushRadius; by <= brushRadius; by++) {\r\n            for (let bx = -brushRadius; bx <= brushRadius; bx++) {\r\n                const nx = x + bx;\r\n                const ny = y + by;\r\n                if (!inBounds(nx, ny)) continue;\r\n\r\n                // Circle-ish brush\r\n                if ((bx * bx + by * by) > brushRadius * brushRadius) continue;\r\n                grid[ny][nx] = tileType;\r\n            }\r\n        }\r\n\r\n        // Step with slight momentum\r\n        const [dx, dy] = dirs[randInt(rng, 0, dirs.length - 1)];\r\n        x = Math.max(1, Math.min(GRID_W - 2, x + dx));\r\n        y = Math.max(1, Math.min(GRID_H - 2, y + dy));\r\n\r\n        // Occasionally change brush size slightly to avoid perfect blobs\r\n        if (rng() < 0.12) {\r\n            brushRadius = Math.max(1, Math.min(3, brushRadius + (rng() < 0.5 ? -1 : 1)));\r\n        }\r\n    }\r\n}\r\n\r\nfunction paintRingsAroundWater(rng, grid) {\r\n    // First pass: sand around water\r\n    const next = cloneGrid(grid);\r\n\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            if (grid[y][x] !== \"grass\") continue;\r\n\r\n            const nearWater = count8(grid, x, y, \"water\");\r\n            if (nearWater >= 1 && rng() < 0.85) {\r\n                next[y][x] = \"sand\";\r\n            }\r\n        }\r\n    }\r\n\r\n    // Second pass: mud around water (and sometimes around sand)\r\n    const next2 = cloneGrid(next);\r\n\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            if (next[y][x] !== \"grass\" && next[y][x] !== \"sand\") continue;\r\n\r\n            const nearWater = count8(next, x, y, \"water\");\r\n            const nearSand = count8(next, x, y, \"sand\");\r\n\r\n            // Mud is more patchy than sand\r\n            if (nearWater >= 1 && rng() < 0.45) {\r\n                next2[y][x] = \"mud\";\r\n            } else if (nearSand >= 3 && rng() < 0.22) {\r\n                next2[y][x] = \"mud\";\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            grid[y][x] = next2[y][x];\r\n        }\r\n    }\r\n}\r\n\r\nfunction growStoneClusters(rng, grid) {\r\n    // Place a few seeds, then grow outward like lichen/rock outcrops.\r\n    const seeds = randInt(rng, 2, 4);\r\n    const frontier = [];\r\n\r\n    for (let i = 0; i < seeds; i++) {\r\n        const x = randInt(rng, 0, GRID_W - 1);\r\n        const y = randInt(rng, 0, GRID_H - 1);\r\n\r\n        // Avoid dumping stone on top of water/beaches\r\n        if (grid[y][x] === \"water\") continue;\r\n        if (count8(grid, x, y, \"water\") > 0) continue;\r\n\r\n        grid[y][x] = \"stone\";\r\n        frontier.push([x, y]);\r\n    }\r\n\r\n    // Growth steps\r\n    const steps = randInt(rng, 35, 70);\r\n\r\n    for (let i = 0; i < steps; i++) {\r\n        if (frontier.length === 0) break;\r\n\r\n        const idx = randInt(rng, 0, frontier.length - 1);\r\n        const [fx, fy] = frontier[idx];\r\n\r\n        const dirs = [\r\n            [1, 0],\r\n            [-1, 0],\r\n            [0, 1],\r\n            [0, -1],\r\n            [1, 1],\r\n            [1, -1],\r\n            [-1, 1],\r\n            [-1, -1],\r\n        ];\r\n\r\n        const [dx, dy] = dirs[randInt(rng, 0, dirs.length - 1)];\r\n        const nx = fx + dx;\r\n        const ny = fy + dy;\r\n\r\n        if (!inBounds(nx, ny)) continue;\r\n        if (grid[ny][nx] !== \"grass\") continue;\r\n\r\n        // Stone prefers to grow near stone, but not endlessly.\r\n        const nearStone = count8(grid, nx, ny, \"stone\");\r\n        const nearWater = count8(grid, nx, ny, \"water\");\r\n\r\n        if (nearWater > 0) continue;\r\n\r\n        const chance = 0.20 + nearStone * 0.12; // 0.32.. etc\r\n        if (rng() < chance) {\r\n            grid[ny][nx] = \"stone\";\r\n            frontier.push([nx, ny]);\r\n        }\r\n\r\n        // Occasionally prune the frontier so it doesn't explode\r\n        if (frontier.length > 120 && rng() < 0.25) {\r\n            frontier.splice(idx, 1);\r\n        }\r\n    }\r\n}\r\n\r\nfunction cleanupSpeckles(rng, grid) {\r\n    // Remove lonely single tiles (especially sand/mud/stone dots)\r\n    const next = cloneGrid(grid);\r\n\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            const t = grid[y][x];\r\n            if (t === \"water\") continue;\r\n\r\n            const same = count8(grid, x, y, t);\r\n\r\n            // If a tile has basically no support, nudge it back to grass.\r\n            if ((t === \"sand\" || t === \"mud\" || t === \"stone\") && same <= 1) {\r\n                // But keep beaches if they are near water\r\n                const nearWater = count8(grid, x, y, \"water\");\r\n                if (nearWater >= 2) continue;\r\n\r\n                if (rng() < 0.85) {\r\n                    next[y][x] = \"grass\";\r\n                }\r\n            }\r\n\r\n            // If grass is surrounded by water, convert it to water (fills holes)\r\n            if (t === \"grass\") {\r\n                const waterN = count8(grid, x, y, \"water\");\r\n                if (waterN >= 6 && rng() < 0.40) {\r\n                    next[y][x] = \"water\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            grid[y][x] = next[y][x];\r\n        }\r\n    }\r\n}\r\n\r\nexport function generateNaturalBaseGrid(rng, baseGrid) {\r\n    // 0) Start grass\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            baseGrid[y][x] = \"grass\";\r\n        }\r\n    }\r\n\r\n    // 1) One main lake\r\n    {\r\n        const sx = randInt(rng, Math.floor(GRID_W * 0.25), Math.floor(GRID_W * 0.75));\r\n        const sy = randInt(rng, Math.floor(GRID_H * 0.25), Math.floor(GRID_H * 0.75));\r\n\r\n        const steps = randInt(rng, 55, 85);\r\n        const brush = randInt(rng, 2, 3);\r\n\r\n        randomWalkCarve(rng, baseGrid, \"water\", sx, sy, steps, brush);\r\n    }\r\n\r\n    // 2) Sometimes add a smaller pond\r\n    if (rng() < 0.55) {\r\n        const sx = randInt(rng, 2, GRID_W - 3);\r\n        const sy = randInt(rng, 2, GRID_H - 3);\r\n\r\n        const steps = randInt(rng, 18, 35);\r\n        const brush = randInt(rng, 1, 2);\r\n\r\n        randomWalkCarve(rng, baseGrid, \"water\", sx, sy, steps, brush);\r\n    }\r\n\r\n    // 3) Add sand + mud around water\r\n    paintRingsAroundWater(rng, baseGrid);\r\n\r\n    // 4) Grow stone outcrops away from water\r\n    growStoneClusters(rng, baseGrid);\r\n\r\n    // 5) A bit of cleanup\r\n    cleanupSpeckles(rng, baseGrid);\r\n\r\n    // 6) Extra tiny touch: a few mud pockets in grassy lowlands\r\n    // (adds variety without ruining readability)\r\n    for (let i = 0; i < 20; i++) {\r\n        const x = randInt(rng, 0, GRID_W - 1);\r\n        const y = randInt(rng, 0, GRID_H - 1);\r\n\r\n        if (baseGrid[y][x] !== \"grass\") continue;\r\n        if (count8(baseGrid, x, y, \"water\") > 0) continue;\r\n        if (count8(baseGrid, x, y, \"stone\") > 0) continue;\r\n\r\n        if (rng() < 0.15) {\r\n            baseGrid[y][x] = \"mud\";\r\n        }\r\n    }\r\n\r\n    // Optional: soften isolated mud dots a bit\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            if (baseGrid[y][x] !== \"mud\") continue;\r\n            if (count4(baseGrid, x, y, \"mud\") === 0 && rng() < 0.70) {\r\n                baseGrid[y][x] = \"grass\";\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { GRID_W, GRID_H } from \"./config.js\";\r\nimport { mulberry32 } from \"./helpers.js\";\r\nimport { PLANT_REGISTRY } from \"./plants/registry.js\";\r\n\r\nexport function tickPlants(state) {\r\n    const coords = [];\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            if (state.plantGrid[y][x]) coords.push([x, y]);\r\n        }\r\n    }\r\n\r\n    state.rng = mulberry32((Date.now() + state.seedCounter) & 0xffffffff);\r\n    state.seedCounter++;\r\n\r\n    for (const [x, y] of coords) {\r\n        const st = state.plantGrid[y][x];\r\n        if (!st) continue;\r\n\r\n        const cls = PLANT_REGISTRY[st.plantType];\r\n        if (!cls) {\r\n            state.plantGrid[y][x] = null;\r\n            continue;\r\n        }\r\n\r\n        if (!cls.canPlantOn(x, y, state)) {\r\n            state.plantGrid[y][x] = null;\r\n            continue;\r\n        }\r\n\r\n        cls.onTick(x, y, state);\r\n    }\r\n}\r\n","import { GRID_W, GRID_H, TILE_SIZE, TILE_COLOURS, COLOUR } from \"./config.js\";\r\nimport { PLANT_REGISTRY } from \"./plants/registry.js\";\r\n\r\nexport function drawFrame(state, ctx) {\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            ctx.fillStyle = TILE_COLOURS[state.baseGrid[y][x]] || \"#777\";\r\n            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\r\n        }\r\n    }\r\n\r\n    if (state.showGrid) {\r\n        ctx.strokeStyle = COLOUR.gridLine;\r\n        ctx.lineWidth = 1;\r\n\r\n        for (let x = 0; x <= GRID_W; x++) {\r\n            const px = x * TILE_SIZE + 0.5;\r\n            ctx.beginPath();\r\n            ctx.moveTo(px, 0);\r\n            ctx.lineTo(px, GRID_H * TILE_SIZE);\r\n            ctx.stroke();\r\n        }\r\n\r\n        for (let y = 0; y <= GRID_H; y++) {\r\n            const py = y * TILE_SIZE + 0.5;\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, py);\r\n            ctx.lineTo(GRID_W * TILE_SIZE, py);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    for (let y = 0; y < GRID_H; y++) {\r\n        for (let x = 0; x < GRID_W; x++) {\r\n            const st = state.plantGrid[y][x];\r\n            if (!st) continue;\r\n\r\n            const cls = PLANT_REGISTRY[st.plantType];\r\n            if (!cls) continue;\r\n\r\n            cls.draw(ctx, x * TILE_SIZE, y * TILE_SIZE, st);\r\n        }\r\n    }\r\n}\r\n"],"names":["$ba30e20475feac5a$export$315a7bb69757d5a7","$ba30e20475feac5a$export$34ddeca23ac38a20","$ba30e20475feac5a$export$619b51fcfd7c4956","mud","grass","water","sand","stone","$29289ae2f853543e$export$39c1b8934bddc9a6","g","y","row","x","push","$bd02c871d9c5ba8e$export$4e985c1b25c164db","$bd02c871d9c5ba8e$export$ae06a31eb29cbddb","$bd02c871d9c5ba8e$export$cb8c62edfcec0fd2","out","dy","dx","$bd02c871d9c5ba8e$export$7d15b64cf5a3a4c4","v","a","b","Math","max","min","$bd02c871d9c5ba8e$export$d22a027dada4117a","seed","t","imul","$2bd4c572d50c8c3c$export$72afe9c85ade6759","typeName","displayName","maxStage","getDescription","_x","_y","_state","canPlantOn","init","plant","state","plantGrid","plantType","stage","age","data","onTick","st","draw","_ctx","_px","_py","ctx","strokeStyle","lineWidth","strokeRect","px","py","TILE_SIZE","_countPlantsInRadius","cx","cy","r","n","_countPlantsInMoore","_isCrowdedForSpreading","occupied","nx","ny","_trySpreadTo","_fromX","_fromY","toX","toY","canPlantOnFn","$e6d73616bebf33a6$export$e6c4aaad6785574a","baseTile","baseGrid","_isDeepWaterPocket","fast","cap","local","orth","filter","i","length","j","floor","rng","slice","sort","ta","bottom","top","midX","beginPath","moveTo","lineTo","stroke","$596ac2c908efdf81$export$9a60c84efaf62b31","color","candidates","ca","parentColour","childColour","options","colours","c","child","petalR","centreR","colourByName","white","yellow","pink","lavender","petalColour","fillStyle","arc","PI","fill","$aee5caf8454147df$export$78990388006fc58f","colour","flowering","bloomAge","_colourToRGB","name","map","red","blue","green","cyan","magenta","_pickSpreadTarget","nearCactus","weight","total","roll","local2","timeStop","baseStop","startChance","local3","target","rr","bodyH","bx","by","arcTo","closePath","sx","cols","yy","dir","topY","$c6a75af8f4fb0994$export$8ac37319d3c8ed52","base","colourByTile","$709369b466786239$export$f19b6aa86008a814","moved","adj","adjWanderers","other","targets","tx","ty","magic","$b0bb96384d34d4b5$export$58ada19cd5f35ee9","otherCls","$ae605652761ddad2$export$853aac19120fead9","_st","$b8a2607e32fe05cd$export$b4a25d14236c1d1b","_pickCapWeighted","weighted","w","_countHostileAdjacency","ax","ay","valid","sy","stemH","capR","capByName","brown","tan","cream","orange","purple","black","glow","capFill","fillRect","stemW","$bd8aba2dd7d109a5$export$6c157b3ee5a67478","hue","hues","_hueToColour","mint","teal","gold","rust","near","parentHue","childHue","h","$a91a379d18c4a638$export$b75a6b61dc760dd5","waterCount","notchAngle","ellipse","$910dbe2a5f197a40$export$aad56179aff78418","_pickColourWeighted","salmon","peach","deepblue","crimson","scarlet","hotpink","violet","bloomR","$84136c0d47d3c86e$export$8c5df996010e4ff2","y0","leftX","x0","rightX","$ae605652761ddad2$export$37c4892f14cb3149","$ae605652761ddad2$export$b1ef01852a007257","daisy","reed","cactus","chromatic","wanderer","blight","fence","mushroom","lichen","geranium","lily","$ce3de23872348272$export$1042faa6df30c26","refund","cls","ceil","$0e3ac76a52ae2277$var$randInt","maxInclusive","$0e3ac76a52ae2277$var$cloneGrid","grid","$0e3ac76a52ae2277$var$count8","tileType","$0e3ac76a52ae2277$var$randomWalkCarve","startX","startY","steps","brushRadius","dirs","$0e3ac76a52ae2277$export$ae8c9f3c07d89ec0","brush","$0e3ac76a52ae2277$var$paintRingsAroundWater","next","nearWater","next2","nearSand","$0e3ac76a52ae2277$var$growStoneClusters","seeds","frontier","idx","fx","fy","nearStone","chance","splice","$0e3ac76a52ae2277$var$cleanupSpeckles","same","waterN","$0e3ac76a52ae2277$var$count4","$f9a85cdfa1754a18$export$1b8933bdb9567194","count","magicCount","document","getElementById","textContent","String","$54b47fc030b7b21e$var$state","selectedTool","selectedValue","paused","showGrid","seedCounter","$54b47fc030b7b21e$var$canvas","$54b47fc030b7b21e$var$ctx","getContext","width","height","refreshButtons","$54b47fc030b7b21e$var$refreshButtons","canvas","tileButtons","seedButtons","tickPill","gridPill","inspector","makeButton","label","kind","value","swatchColour","cost","createElement","className","dataset","s","style","background","appendChild","addEventListener","tileBtnEls","el","seedBtnEls","isSel","classList","toggle","getGridPosFromEvent","e","rect","getBoundingClientRect","mx","clientX","left","my","clientY","gx","gy","applyToolAt","button","includes","setInspector","text","preventDefault","dragging","dragButton","lastCellKey","lastInspectKey","gp","key","describeCell","window","repeat","raw","localStorage","getItem","JSON","parse","Array","isArray","plants","cell","pt","setInterval","coords","Date","now","$54b47fc030b7b21e$var$loop","requestAnimationFrame","setItem","stringify"],"version":3,"file":"garden.a47efa89.js.map"}